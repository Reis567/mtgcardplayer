<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Partida - MTG Commander</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #0a0a12;
            color: #eee;
            min-height: 100vh;
            overflow: hidden;
        }
        .game-container {
            display: grid;
            grid-template-rows: auto auto 1fr;
            height: 100vh;
            gap: 4px;
            padding: 4px;
            padding-right: 75px; /* Space for side zones panel */
        }

        /* ===== HEADER ===== */
        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(255,255,255,0.05);
            padding: 5px 10px;
            border-radius: 5px;
        }
        .turn-info { display: flex; gap: 10px; align-items: center; font-size: 0.9rem; }
        .turn-info .turn { color: #e94560; font-weight: bold; }
        .turn-info .active { color: #ffc107; }
        .connection-status { display: flex; align-items: center; gap: 5px; font-size: 0.75rem; }
        .connection-dot { width: 7px; height: 7px; border-radius: 50%; background: #c0392b; }
        .connection-dot.connected { background: #27ae60; }
        .game-controls button {
            padding: 5px 10px;
            margin-left: 5px;
            background: rgba(255,255,255,0.1);
            border: none;
            border-radius: 4px;
            color: white;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.2s;
        }
        .game-controls button:hover { background: rgba(255,255,255,0.2); }
        .game-controls button.primary { background: #e94560; }

        /* ===== PHASE TRACKER ===== */
        .phase-tracker {
            display: flex;
            align-items: center;
            background: rgba(255,255,255,0.03);
            border-radius: 5px;
            padding: 4px 8px;
            overflow-x: auto;
            gap: 2px;
            position: relative;
        }
        .phase-group {
            display: flex;
            align-items: center;
            gap: 2px;
        }
        .phase-group-label {
            font-size: 0.55rem;
            color: #666;
            text-transform: uppercase;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            transform: rotate(180deg);
            padding: 2px;
        }
        .phase-btn {
            padding: 5px 7px;
            border: none;
            border-radius: 3px;
            background: rgba(255,255,255,0.05);
            color: #888;
            cursor: pointer;
            font-size: 0.7rem;
            transition: all 0.2s;
            white-space: nowrap;
        }
        .phase-btn:hover { background: rgba(255,255,255,0.1); color: #ccc; }
        .phase-btn.active {
            background: #e94560;
            color: white;
            font-weight: bold;
        }
        .phase-btn.passed {
            background: rgba(78, 205, 196, 0.2);
            color: #4ecdc4;
        }
        .phase-separator {
            width: 1px;
            height: 20px;
            background: #333;
            margin: 0 4px;
        }
        .phase-next-btn {
            padding: 5px 12px;
            background: #4ecdc4;
            border: none;
            border-radius: 3px;
            color: #000;
            cursor: pointer;
            font-size: 0.75rem;
            font-weight: bold;
            margin-left: 8px;
        }
        .phase-next-btn:hover { background: #3dbdb5; }
        .phase-next-btn:disabled {
            background: #555;
            color: #888;
            cursor: not-allowed;
        }
        .phase-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .phase-btn:disabled:hover {
            transform: none;
        }
        .phase-tracker.not-my-turn {
            opacity: 0.7;
        }
        .phase-tracker.not-my-turn::after {
            content: '(Aguardando sua vez)';
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 0.65rem;
            color: #e94560;
        }

        /* ===== PLAYERS GRID ===== */
        .players-grid {
            display: grid;
            gap: 4px;
            overflow: hidden;
            min-height: 0;
        }
        .players-grid[data-players="2"] { grid-template-columns: 1fr; grid-template-rows: 1fr 1fr; }
        .players-grid[data-players="3"] { grid-template-columns: 1fr 1fr; grid-template-rows: 1fr 1fr; }
        .players-grid[data-players="4"] { grid-template-columns: 1fr 1fr; grid-template-rows: 1fr 1fr; }
        .players-grid[data-players="5"] { grid-template-columns: repeat(3, 1fr); grid-template-rows: 1fr 1fr; }
        .players-grid[data-players="6"] { grid-template-columns: repeat(3, 1fr); grid-template-rows: 1fr 1fr; }
        .players-grid[data-players="7"] { grid-template-columns: repeat(4, 1fr); grid-template-rows: 1fr 1fr; }
        .players-grid[data-players="8"] { grid-template-columns: repeat(4, 1fr); grid-template-rows: 1fr 1fr; }

        /* ===== PLAYER AREA ===== */
        .player-area {
            background: rgba(255,255,255,0.02);
            border-radius: 6px;
            padding: 5px;
            display: flex;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
            border: 2px solid transparent;
            transition: border-color 0.3s;
            position: relative;
        }
        .player-area.is-me { border-color: rgba(233, 69, 96, 0.3); }
        .player-area.active-turn { border-color: #ffc107; }
        .player-area.dead { opacity: 0.5; }
        .player-area.drag-over-player {
            border-color: #4ecdc4 !important;
            background: rgba(78, 205, 196, 0.08);
        }
        .player-area.arrow-target {
            outline: 3px dashed #e94560;
            outline-offset: -3px;
        }

        .player-header {
            display: flex;
            align-items: center;
            gap: 6px;
            padding-bottom: 3px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            margin-bottom: 3px;
            flex-shrink: 0;
        }
        .player-avatar {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.85rem;
            cursor: pointer;
            position: relative;
        }
        .player-avatar:hover { opacity: 0.8; }
        .player-info { flex: 1; min-width: 0; }
        .player-info .name { font-size: 0.8rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .player-info .stats { display: flex; gap: 6px; font-size: 0.7rem; color: #888; }
        .commander-link {
            font-size: 0.65rem;
            color: #ffc107;
            cursor: pointer;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 150px;
            opacity: 0.8;
            transition: opacity 0.2s;
        }
        .commander-link:hover { opacity: 1; text-decoration: underline; }

        /* Life and Counters */
        .player-life-counters {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .player-life {
            display: flex;
            align-items: center;
            gap: 2px;
        }
        .player-life .life {
            font-size: 1.1rem;
            font-weight: bold;
            color: #4ecdc4;
            min-width: 30px;
            text-align: center;
        }
        .player-life button {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: none;
            background: rgba(255,255,255,0.1);
            color: white;
            cursor: pointer;
            font-size: 0.85rem;
            line-height: 1;
        }
        .player-life button:hover { background: rgba(255,255,255,0.2); }

        /* Generic Counters */
        .generic-counters {
            display: flex;
            gap: 3px;
        }
        .generic-counter {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.65rem;
            font-weight: bold;
            cursor: pointer;
            border: 1px solid rgba(255,255,255,0.2);
            transition: transform 0.1s;
        }
        .generic-counter:hover { transform: scale(1.1); }
        .generic-counter.red { background: #e94560; color: white; }
        .generic-counter.blue { background: #3498db; color: white; }
        .generic-counter.green { background: #27ae60; color: white; }
        .generic-counter.yellow { background: #f1c40f; color: #333; }
        .generic-counter.purple { background: #9b59b6; color: white; }

        .player-zones-mini {
            display: flex;
            gap: 4px;
            font-size: 0.65rem;
            margin-left: auto;
        }
        .mini-zone {
            background: rgba(0,0,0,0.3);
            padding: 3px 5px;
            border-radius: 3px;
            cursor: pointer;
        }
        .mini-zone:hover { background: rgba(255,255,255,0.1); }

        /* ===== BATTLEFIELD ===== */
        .player-battlefield {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 2px;
            min-height: 0;
            overflow-y: auto;
            overflow-x: hidden;
        }
        .battlefield-row {
            min-height: 70px;
            border-radius: 4px;
            padding: 5px 8px;
            position: relative;
            transition: all 0.2s;
            flex-shrink: 1;
            overflow: hidden;
        }
        .battlefield-row.drag-over {
            background: rgba(78, 205, 196, 0.15) !important;
            outline: 2px dashed #4ecdc4;
        }
        .creatures-row { background: rgba(233, 69, 96, 0.06); }
        .enchantments-row { background: rgba(78, 205, 196, 0.06); }
        .lands-row { background: rgba(255, 193, 7, 0.06); }
        .cards-container {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            min-height: 60px;
            align-content: flex-start;
        }

        /* ===== SIDE ZONES (Right Panel) ===== */
        .my-zones-row {
            position: fixed;
            right: 10px;
            bottom: 10px;
            z-index: 500;
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 10px 8px;
            background: rgba(15, 15, 25, 0.95);
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: -3px 0 15px rgba(0,0,0,0.5);
        }
        .zone-stack {
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            position: relative;
            transition: transform 0.2s;
        }
        .zone-stack:hover { transform: translateY(-2px); }
        .stack-visual {
            position: relative;
            width: 46px;
            height: 64px;
        }
        .card-back {
            position: absolute;
            width: 46px;
            height: 64px;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border: 2px solid #333;
            border-radius: 3px;
        }
        .card-back.offset-1 { top: 2px; left: 2px; }
        .card-back.offset-2 { top: 4px; left: 4px; }
        .zone-count {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1rem;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 1px 3px rgba(0,0,0,0.8);
        }
        .zone-label {
            margin-top: 2px;
            font-size: 0.6rem;
            color: #777;
        }
        .graveyard-zone .top-card,
        .exile-zone .top-card {
            width: 46px;
            height: 64px;
            border-radius: 3px;
            overflow: hidden;
        }
        .graveyard-zone .top-card img,
        .exile-zone .top-card img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .command-zone-stack {
            border: 2px dashed #e94560;
            padding: 4px;
            border-radius: 4px;
            min-width: 54px;
            min-height: 70px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .command-zone-stack .commanders-container {
            display: flex;
            gap: 2px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .command-zone-stack .card { width: 46px; height: 64px; }

        /* ===== MY HAND (Collapsible) ===== */
        .hand-toggle-btn {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 600;
            background: #e94560;
            border: none;
            border-radius: 20px 20px 0 0;
            color: white;
            padding: 6px 20px;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: bold;
            box-shadow: 0 -2px 10px rgba(233, 69, 96, 0.5);
            transition: all 0.2s;
        }
        .hand-toggle-btn:hover { background: #ff6b8a; }
        .hand-toggle-btn.hand-open { display: none; }

        .my-hand-container {
            position: fixed;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%) translateY(100%);
            z-index: 550;
            background: rgba(15, 15, 25, 0.98);
            border-radius: 10px 10px 0 0;
            padding: 8px 15px 10px;
            border-top: 3px solid #e94560;
            box-shadow: 0 -5px 30px rgba(0,0,0,0.7);
            max-width: 95vw;
            max-height: 45vh;
            overflow-y: auto;
            transition: transform 0.3s ease-out;
        }
        .my-hand-container.show {
            transform: translateX(-50%) translateY(0);
        }
        .my-hand-container.drag-over {
            background: rgba(78, 205, 196, 0.15);
            border-top-color: #4ecdc4;
            box-shadow: inset 0 0 20px rgba(78, 205, 196, 0.2);
        }
        .my-hand-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }
        .my-hand-container h3 { font-size: 0.85rem; margin: 0; }
        .hand-close-btn {
            background: rgba(255,255,255,0.1);
            border: none;
            border-radius: 4px;
            color: #888;
            padding: 4px 10px;
            cursor: pointer;
            font-size: 0.75rem;
        }
        .hand-close-btn:hover { background: rgba(255,255,255,0.2); color: white; }

        /* Fullscreen prompt */
        .fullscreen-prompt {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.95);
            z-index: 3000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 20px;
        }
        .fullscreen-prompt h2 { color: #e94560; font-size: 1.5rem; }
        .fullscreen-prompt p { color: #aaa; font-size: 0.9rem; text-align: center; max-width: 400px; }
        .fullscreen-prompt button {
            padding: 12px 30px;
            border: none;
            border-radius: 6px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        .fullscreen-prompt .btn-fullscreen {
            background: #e94560;
            color: white;
        }
        .fullscreen-prompt .btn-fullscreen:hover { background: #ff6b8a; }
        .fullscreen-prompt .btn-skip {
            background: transparent;
            color: #666;
            border: 1px solid #444;
        }
        .fullscreen-prompt .btn-skip:hover { color: #aaa; border-color: #666; }
        .hand-cards {
            display: flex;
            gap: 2px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .hand-cards .card {
            width: 80px;
            height: 112px;
            cursor: grab;
            transition: transform 0.15s ease-out, margin 0.18s ease-out, opacity 0.15s;
            user-select: none;
        }
        .hand-cards .card:hover {
            transform: translateY(-10px) scale(1.05);
            z-index: 100;
        }
        .hand-cards .card.dragging {
            opacity: 0.4;
            cursor: grabbing;
            transform: scale(0.95);
            z-index: 200;
        }
        .hand-cards .card.drag-over-left {
            margin-left: 45px;
        }
        .hand-cards .card.drag-over-right {
            margin-right: 45px;
        }
        .hand-cards .card.drag-placeholder {
            opacity: 0.3;
            transform: scale(0.95);
        }
        .hand-cards .card img {
            pointer-events: none;
            user-select: none;
        }
        /* Prevent hover effects during drag */
        .hand-cards.dragging-active .card:not(.dragging):hover {
            transform: none;
        }

        /* ===== SIDEBAR (Chat/Log) ===== */
        .sidebar-toggle {
            position: fixed;
            top: 45px;
            right: 8px;
            z-index: 100;
            background: rgba(255,255,255,0.1);
            border: none;
            border-radius: 4px;
            color: white;
            padding: 6px 10px;
            cursor: pointer;
            font-size: 0.75rem;
        }
        .sidebar {
            position: fixed;
            top: 0;
            right: 0;
            width: 240px;
            height: 100vh;
            background: rgba(10, 10, 18, 0.98);
            border-left: 1px solid #333;
            display: flex;
            flex-direction: column;
            transform: translateX(100%);
            transition: transform 0.3s;
            z-index: 200;
            padding: 6px;
        }
        .sidebar.open { transform: translateX(0); }
        .sidebar-close {
            align-self: flex-end;
            background: none;
            border: none;
            color: #888;
            cursor: pointer;
            font-size: 1.1rem;
        }
        .chat-panel, .log-panel {
            background: rgba(255,255,255,0.03);
            border-radius: 5px;
            padding: 6px;
            margin-bottom: 6px;
        }
        .chat-panel { max-height: 140px; display: flex; flex-direction: column; }
        .log-panel { flex: 1; overflow-y: auto; }
        .chat-panel h3, .log-panel h3 { margin-bottom: 4px; font-size: 0.7rem; color: #888; }
        .chat-messages { flex: 1; overflow-y: auto; margin-bottom: 4px; max-height: 60px; }
        .chat-message, .log-entry { font-size: 0.65rem; padding: 2px 0; }
        .chat-message .sender { color: #4ecdc4; }
        .log-entry { border-bottom: 1px solid rgba(255,255,255,0.05); }
        .log-entry .turn-num { color: #e94560; }
        .chat-input-container { display: flex; gap: 3px; }
        .chat-input-container input {
            flex: 1;
            padding: 4px;
            border: none;
            border-radius: 3px;
            background: rgba(255,255,255,0.1);
            color: white;
            font-size: 0.7rem;
        }
        .chat-input-container button {
            padding: 4px 6px;
            border: none;
            border-radius: 3px;
            background: #e94560;
            color: white;
            cursor: pointer;
            font-size: 0.7rem;
        }

        /* ===== CARDS ===== */
        .card {
            width: 85px;
            height: 119px;
            border-radius: 5px;
            overflow: hidden;
            cursor: pointer;
            position: relative;
            transition: transform 0.15s;
            border: 2px solid transparent;
        }
        .card:hover { transform: scale(1.08); z-index: 10; }
        .card.tapped { transform: rotate(90deg); margin: 15px 20px; }
        .card.tapped:hover { transform: rotate(90deg) scale(1.08); }
        .card.selected { border-color: #e94560; box-shadow: 0 0 6px rgba(233, 69, 96, 0.5); }
        .card.commander { border-color: #ffc107; }
        .card.dragging { opacity: 0.4; }
        .card.arrow-source { box-shadow: 0 0 10px #e94560; }
        .card.has-arrow { box-shadow: 0 0 8px 2px #ffc107; }
        .card.arrow-target-card {
            outline: 2px dashed #4ecdc4;
            outline-offset: 2px;
        }
        .card.arrow-target-card:hover {
            outline-color: #e94560;
            cursor: crosshair;
        }
        .card img { width: 100%; height: 100%; object-fit: cover; pointer-events: none; }
        .card .counters {
            position: absolute;
            bottom: 1px;
            right: 1px;
            background: rgba(0,0,0,0.85);
            padding: 1px 3px;
            border-radius: 2px;
            font-size: 0.5rem;
        }

        /* Card Stack - horizontal cascade (staircase to the left) */
        .card-stack {
            position: relative;
            display: inline-flex;
            align-items: flex-start;
        }
        .card-stack .card {
            flex-shrink: 0;
        }
        .card-stack .card.stacked {
            margin-right: -68px; /* Show ~17px of each card's left edge */
        }
        .card-stack .card.stack-top {
            position: relative;
            z-index: 10;
        }
        .card.stack-drop-target {
            outline: 3px dashed #4ecdc4;
            outline-offset: 2px;
        }
        /* Tapped cards in stack */
        .card-stack .card.stacked.tapped {
            transform: rotate(90deg);
            margin-right: -68px;
            margin-top: 10px;
            margin-bottom: 10px;
        }
        .card-stack .card.stack-top.tapped {
            transform: rotate(90deg);
            margin: 10px 15px;
        }

        /* ===== ARROWS ===== */
        .arrows-svg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 500;
            overflow: visible;
        }
        .arrow-line {
            stroke: #e94560;
            stroke-width: 4;
            fill: none;
            marker-end: url(#arrowhead);
            pointer-events: visibleStroke;
            cursor: pointer;
            filter: drop-shadow(0 0 4px rgba(233, 69, 96, 0.9));
            transition: stroke-width 0.15s;
        }
        .arrow-line:hover {
            stroke: #ff6b8a;
            stroke-width: 6;
            filter: drop-shadow(0 0 6px rgba(255, 107, 138, 1));
        }

        /* ===== SELECTION BOX ===== */
        .selection-box {
            position: fixed;
            border: 2px dashed #e94560;
            background: rgba(233, 69, 96, 0.15);
            pointer-events: none;
            z-index: 1000;
            display: none;
        }
        .card.selection-preview {
            outline: 2px solid #e94560;
            outline-offset: 2px;
        }

        /* ===== CONTEXT MENU ===== */
        .context-menu {
            position: fixed;
            background: #1a1a2e;
            border: 1px solid #333;
            border-radius: 5px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            z-index: 2000;
            min-width: 140px;
            overflow: hidden;
            display: none;
        }
        .context-menu.show { display: block; }
        .context-menu-item {
            padding: 6px 8px;
            cursor: pointer;
            font-size: 0.75rem;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .context-menu-item:hover { background: rgba(233, 69, 96, 0.2); }
        .context-menu-item.disabled { opacity: 0.5; cursor: not-allowed; }
        .context-menu-divider { height: 1px; background: #333; margin: 2px 0; }

        /* ===== MODALS ===== */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.9);
            z-index: 1500;
            display: none;
            align-items: center;
            justify-content: center;
        }
        .modal-overlay.show { display: flex; }
        .modal-content {
            background: #16213e;
            border-radius: 8px;
            padding: 15px;
            max-width: 90vw;
            max-height: 80vh;
            overflow: auto;
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .modal-header h3 { font-size: 0.9rem; }
        .modal-header button {
            background: #333;
            border: none;
            color: white;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.75rem;
        }
        .modal-cards {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            justify-content: center;
        }
        .modal-cards .card { width: 85px; height: 119px; cursor: pointer; }
        .modal-cards .card.selected {
            border: 3px solid #e94560;
            box-shadow: 0 0 10px rgba(233, 69, 96, 0.6);
        }
        .modal-cards .card.dragging { opacity: 0.5; }
        .zone-viewer-actions {
            display: flex;
            gap: 8px;
            margin-top: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }
        .zone-viewer-actions button {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75rem;
            background: #e94560;
            color: white;
        }
        .zone-viewer-actions button:hover { background: #ff6b8a; }
        .zone-viewer-actions button:disabled {
            background: #444;
            color: #888;
            cursor: not-allowed;
        }
        .zone-viewer-actions .selection-count {
            color: #4ecdc4;
            font-size: 0.8rem;
            align-self: center;
        }

        /* Mulligan Modal */
        .mulligan-modal {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.95);
            z-index: 2000;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            gap: 15px;
            padding: 20px;
        }
        .mulligan-modal.show { display: flex; }
        .mulligan-modal h3 {
            color: #e94560;
            font-size: 1.2rem;
            margin: 0;
        }
        .mulligan-modal p {
            color: #aaa;
            font-size: 0.9rem;
            margin: 0;
        }
        .mulligan-modal .mulligan-cards {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            max-width: 90vw;
            max-height: 50vh;
            overflow-y: auto;
            padding: 10px;
        }
        .mulligan-card {
            width: 100px;
            height: 140px;
            cursor: pointer;
            transition: transform 0.15s, box-shadow 0.15s;
            border: 3px solid transparent;
            border-radius: 6px;
            background-color: #2a2a3e;
            overflow: hidden;
            position: relative;
        }
        .mulligan-card img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 4px;
            pointer-events: none;
        }
        .mulligan-card:hover {
            transform: scale(1.05);
        }
        .mulligan-card.selected {
            border-color: #e94560;
            box-shadow: 0 0 15px rgba(233, 69, 96, 0.7);
        }
        .mulligan-modal .mulligan-info {
            display: flex;
            gap: 15px;
            align-items: center;
        }
        .mulligan-modal .mulligan-count {
            color: #4ecdc4;
            font-size: 1rem;
        }
        .mulligan-modal button {
            padding: 10px 25px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
        }
        .mulligan-modal button.confirm {
            background: #4ecdc4;
            color: #1a1a2e;
        }
        .mulligan-modal button.confirm:hover { background: #5fded5; }
        .mulligan-modal button.confirm:disabled {
            background: #444;
            color: #888;
            cursor: not-allowed;
        }

        /* Library Viewer */
        .library-viewer-cards {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            justify-content: center;
            max-height: 60vh;
            overflow-y: auto;
            padding: 10px;
        }
        .library-viewer-cards .card {
            width: 70px;
            height: 98px;
            cursor: pointer;
            transition: transform 0.15s, box-shadow 0.15s;
        }
        .library-viewer-cards .card:hover {
            transform: scale(1.1);
            box-shadow: 0 0 10px rgba(78, 205, 196, 0.8);
            z-index: 10;
        }

        /* Card Modal */
        .card-modal {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.9);
            z-index: 1800;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            gap: 10px;
        }
        .card-modal.show { display: flex; }
        .card-modal img { max-height: 55vh; border-radius: 8px; }
        .card-modal .actions { display: flex; gap: 5px; flex-wrap: wrap; justify-content: center; }
        .card-modal button {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75rem;
        }
        .card-modal .close { background: #333; color: white; }
        .card-modal .action-btn { background: #e94560; color: white; }

        /* Scry Modal */
        .scry-modal {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.95);
            z-index: 2000;
            display: none;
            align-items: center;
            justify-content: center;
        }
        .scry-modal.show { display: flex; }
        .scry-content {
            background: #16213e;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            max-width: 90vw;
        }
        .scry-content h3 { margin-bottom: 10px; font-size: 0.9rem; }
        .scry-cards {
            display: flex;
            gap: 8px;
            justify-content: center;
            margin: 10px 0;
            flex-wrap: wrap;
        }
        .scry-cards .card { width: 90px; height: 126px; cursor: grab; }
        .scry-zones {
            display: flex;
            gap: 12px;
            justify-content: center;
            margin: 10px 0;
        }
        .scry-zone {
            min-width: 100px;
            min-height: 60px;
            border: 2px dashed #444;
            border-radius: 5px;
            padding: 6px;
            transition: all 0.2s;
        }
        .scry-zone.drag-over { border-color: #4ecdc4; background: rgba(78, 205, 196, 0.1); }
        .scry-zone span { font-size: 0.7rem; color: #888; display: block; margin-bottom: 4px; }
        .scry-zone .scry-cards-list { display: flex; gap: 4px; flex-wrap: wrap; justify-content: center; }
        .scry-zone .card { width: 45px; height: 63px; }
        .scry-content .btn {
            padding: 6px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            margin-top: 6px;
        }
        .scry-content .btn.primary { background: #e94560; color: white; }

        /* Auto-Pay Mana Modal */
        .autopay-modal {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.95);
            z-index: 2500;
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
        }
        .autopay-modal.show { display: flex; }
        .autopay-content {
            background: #16213e;
            border-radius: 10px;
            padding: 20px;
            max-width: 90vw;
            max-height: 85vh;
            overflow-y: auto;
        }
        .autopay-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            border-bottom: 1px solid #333;
            padding-bottom: 10px;
        }
        .autopay-header h3 { font-size: 1rem; color: #4ecdc4; }
        .autopay-beta {
            background: #e94560;
            color: white;
            font-size: 0.6rem;
            padding: 2px 6px;
            border-radius: 3px;
            margin-left: 8px;
        }
        .autopay-header button {
            background: #333;
            border: none;
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
        }
        .autopay-card-preview {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
        }
        .autopay-card-preview img {
            width: 150px;
            border-radius: 8px;
        }
        .autopay-cost-info {
            flex: 1;
        }
        .autopay-cost-info h4 {
            margin-bottom: 8px;
            color: #ffc107;
        }
        .autopay-mana-cost {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
            margin-bottom: 10px;
        }
        .mana-symbol {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.75rem;
        }
        .mana-symbol.W { background: #f9faf4; color: #333; }
        .mana-symbol.U { background: #0e68ab; color: white; }
        .mana-symbol.B { background: #150b00; color: #ccc; border: 1px solid #444; }
        .mana-symbol.R { background: #d3202a; color: white; }
        .mana-symbol.G { background: #00733e; color: white; }
        .mana-symbol.C { background: #ccc2c0; color: #333; }
        .mana-symbol.generic { background: #888; color: white; }
        .autopay-lands-section h4 {
            margin-bottom: 10px;
            color: #888;
            font-size: 0.85rem;
        }
        .autopay-lands-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 15px;
        }
        .autopay-land-item {
            position: relative;
            cursor: pointer;
            transition: all 0.2s;
        }
        .autopay-land-item img {
            width: 70px;
            border-radius: 5px;
            border: 2px solid transparent;
        }
        .autopay-land-item.selected img {
            border-color: #4ecdc4;
            box-shadow: 0 0 10px rgba(78, 205, 196, 0.5);
        }
        .autopay-land-item.will-tap img {
            border-color: #ffc107;
            box-shadow: 0 0 10px rgba(255, 193, 7, 0.5);
        }
        .autopay-land-item .mana-badge {
            position: absolute;
            bottom: -5px;
            right: -5px;
            display: flex;
            gap: 2px;
        }
        .autopay-land-item .mana-badge .mana-symbol {
            width: 18px;
            height: 18px;
            font-size: 0.6rem;
        }
        .autopay-multi-select {
            background: #1a1a2e;
            border: 1px solid #333;
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 15px;
        }
        .autopay-multi-select h5 {
            color: #e94560;
            margin-bottom: 8px;
            font-size: 0.8rem;
        }
        .multi-mana-options {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        .multi-mana-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }
        .multi-mana-btn.W { background: #f9faf4; color: #333; }
        .multi-mana-btn.U { background: #0e68ab; color: white; }
        .multi-mana-btn.B { background: #150b00; color: #ccc; border: 1px solid #444; }
        .multi-mana-btn.R { background: #d3202a; color: white; }
        .multi-mana-btn.G { background: #00733e; color: white; }
        .multi-mana-btn.C { background: #ccc2c0; color: #333; }
        .multi-mana-btn:hover { transform: scale(1.1); }
        .autopay-status {
            background: rgba(78, 205, 196, 0.1);
            border: 1px solid #4ecdc4;
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 15px;
            font-size: 0.85rem;
        }
        .autopay-status.error {
            background: rgba(233, 69, 96, 0.1);
            border-color: #e94560;
            color: #e94560;
        }
        .autopay-status.success {
            background: rgba(78, 205, 196, 0.1);
            border-color: #4ecdc4;
            color: #4ecdc4;
        }
        .autopay-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
        .autopay-actions button {
            padding: 8px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.85rem;
        }
        .autopay-actions .cancel { background: #333; color: white; }
        .autopay-actions .confirm { background: #4ecdc4; color: #000; font-weight: bold; }
        .autopay-actions .confirm:disabled { background: #555; color: #888; cursor: not-allowed; }

        /* Pay-to-activate sources (Signets, etc) */
        .autopay-pay-sources-divider {
            width: 100%;
            padding: 8px 0;
            margin: 10px 0 5px 0;
            border-top: 1px dashed #555;
            font-size: 0.75rem;
            color: #ffc107;
        }
        .autopay-land-item.pay-to-activate {
            opacity: 0.7;
            position: relative;
        }
        .autopay-land-item.pay-to-activate img {
            border: 2px dashed #ffc107;
        }
        .autopay-land-item.pay-to-activate:hover {
            opacity: 1;
        }
        .autopay-land-item .pay-badge {
            position: absolute;
            top: -5px;
            left: -5px;
            background: #ffc107;
            color: #000;
            font-size: 0.6rem;
            font-weight: bold;
            padding: 2px 4px;
            border-radius: 3px;
        }

        /* Reveal Overlay */
        .reveal-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.85);
            z-index: 3000;
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
        }
        .reveal-overlay.show { display: flex; animation: fadeIn 0.3s; }
        .reveal-overlay img { max-height: 45vh; border-radius: 8px; box-shadow: 0 0 30px rgba(233, 69, 96, 0.5); }
        .reveal-overlay p { margin-top: 10px; font-size: 0.9rem; color: #fff; }

        /* ===== OVERLAYS ===== */
        .dead-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            color: #e94560;
            font-weight: bold;
            font-size: 0.85rem;
            border-radius: 5px;
            z-index: 5;
        }
        .winner-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.9);
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 2000;
        }
        .winner-overlay.show { display: flex; }
        .winner-overlay h1 { color: #ffc107; font-size: 1.8rem; margin-bottom: 10px; }
        .winner-overlay a {
            padding: 8px 16px;
            background: #e94560;
            color: white;
            text-decoration: none;
            border-radius: 5px;
        }
        .loading-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1500;
        }
        .loading-overlay.hidden { display: none; }
        .spinner {
            width: 30px;
            height: 30px;
            border: 3px solid rgba(255,255,255,0.1);
            border-top-color: #e94560;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes cardDraw {
            from { transform: translateY(-30px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        @keyframes shuffle {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-2px) rotate(-1deg); }
            75% { transform: translateX(2px) rotate(1deg); }
        }
        .card.drawing { animation: cardDraw 0.25s ease-out; }
        .zone-stack.shuffling .card-back { animation: shuffle 0.1s ease-in-out 5; }

        /* ===== HELP & KEYWORDS MODALS ===== */
        .help-modal {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.95);
            z-index: 3000;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        .help-modal.show { display: flex; }
        .help-content {
            background: #16213e;
            border-radius: 10px;
            max-width: 900px;
            width: 100%;
            max-height: 85vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        .help-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            background: rgba(0,0,0,0.3);
            border-bottom: 1px solid #333;
        }
        .help-header h2 { font-size: 1.1rem; color: #e94560; margin: 0; }
        .help-header .close-btn {
            background: #333;
            border: none;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2rem;
        }
        .help-header .close-btn:hover { background: #e94560; }
        .help-tabs {
            display: flex;
            background: rgba(0,0,0,0.2);
            border-bottom: 1px solid #333;
        }
        .help-tab {
            padding: 10px 20px;
            border: none;
            background: none;
            color: #888;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s;
            border-bottom: 2px solid transparent;
        }
        .help-tab:hover { color: #ccc; }
        .help-tab.active {
            color: #e94560;
            border-bottom-color: #e94560;
            background: rgba(233, 69, 96, 0.1);
        }
        .help-body {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }
        .help-section { margin-bottom: 25px; }
        .help-section h3 {
            color: #4ecdc4;
            font-size: 0.95rem;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid rgba(78, 205, 196, 0.3);
        }
        .shortcut-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 8px;
        }
        .shortcut-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            background: rgba(0,0,0,0.3);
            border-radius: 5px;
        }
        .shortcut-key {
            background: #e94560;
            color: white;
            padding: 3px 8px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.8rem;
            min-width: 28px;
            text-align: center;
        }
        .shortcut-desc { font-size: 0.8rem; color: #ccc; }
        .help-list {
            list-style: none;
            padding: 0;
        }
        .help-list li {
            padding: 8px 12px;
            background: rgba(0,0,0,0.2);
            margin-bottom: 5px;
            border-radius: 5px;
            font-size: 0.85rem;
            border-left: 3px solid #4ecdc4;
        }
        .help-list li strong { color: #ffc107; }

        /* Keywords Modal */
        .keywords-search {
            padding: 15px 20px;
            background: rgba(0,0,0,0.2);
        }
        .keywords-search input {
            width: 100%;
            padding: 10px 15px;
            border: 1px solid #333;
            border-radius: 5px;
            background: rgba(0,0,0,0.3);
            color: white;
            font-size: 0.9rem;
        }
        .keywords-search input:focus {
            outline: none;
            border-color: #e94560;
        }
        .keywords-search input::placeholder { color: #666; }
        .keywords-categories {
            display: flex;
            gap: 5px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        .category-filter {
            padding: 4px 10px;
            border: 1px solid #444;
            border-radius: 15px;
            background: none;
            color: #888;
            cursor: pointer;
            font-size: 0.7rem;
            transition: all 0.2s;
        }
        .category-filter:hover { border-color: #888; color: #ccc; }
        .category-filter.active { background: #e94560; border-color: #e94560; color: white; }
        .keywords-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
            gap: 10px;
        }
        .keyword-item {
            background: rgba(0,0,0,0.3);
            border-radius: 6px;
            padding: 12px;
            border-left: 3px solid #e94560;
            transition: transform 0.15s;
        }
        .keyword-item:hover { transform: translateX(3px); }
        .keyword-item.hidden { display: none; }
        .keyword-name {
            color: #e94560;
            font-weight: bold;
            font-size: 0.9rem;
            margin-bottom: 5px;
        }
        .keyword-desc {
            color: #aaa;
            font-size: 0.8rem;
            line-height: 1.4;
        }
        .keyword-example {
            margin-top: 8px;
            padding: 8px;
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
            font-size: 0.75rem;
            color: #888;
            font-style: italic;
        }
        .keyword-category {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.65rem;
            margin-left: 8px;
            text-transform: uppercase;
        }
        .keyword-category.evergreen { background: #27ae60; color: white; }
        .keyword-category.evasion { background: #3498db; color: white; }
        .keyword-category.triggered { background: #9b59b6; color: white; }
        .keyword-category.static { background: #1abc9c; color: white; }
        .keyword-category.combat { background: #e67e22; color: white; }
        .keyword-category.mana { background: #f1c40f; color: #333; }
        .keyword-category.protection { background: #e74c3c; color: white; }
        .keyword-category.counter { background: #95a5a6; color: white; }
        .keywords-count {
            text-align: center;
            padding: 10px;
            color: #666;
            font-size: 0.75rem;
        }

        /* Help buttons */
        .help-buttons {
            position: fixed;
            bottom: 10px;
            left: 10px;
            display: flex;
            gap: 5px;
            z-index: 100;
        }
        .help-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            font-size: 1rem;
            transition: transform 0.2s, background 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .help-btn:hover { transform: scale(1.1); }
        .help-btn.guide { background: #e94560; color: white; }
        .help-btn.keywords { background: #4ecdc4; color: #000; font-weight: bold; font-size: 0.8rem; }
        .help-btn.dice { background: #9b59b6; color: white; }

        /* ===== DICE ROLLER ===== */
        .dice-modal {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.9);
            z-index: 3500;
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
        }
        .dice-modal.show { display: flex; }
        .dice-container {
            background: #16213e;
            border-radius: 15px;
            padding: 25px;
            text-align: center;
            min-width: 350px;
        }
        .dice-container h2 { color: #e94560; margin-bottom: 20px; }
        .dice-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin-bottom: 20px;
        }
        .dice-btn {
            width: 60px;
            height: 60px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.9rem;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .dice-btn:hover { transform: scale(1.1); }
        .dice-btn.d4 { background: linear-gradient(135deg, #e74c3c, #c0392b); color: white; }
        .dice-btn.d6 { background: linear-gradient(135deg, #3498db, #2980b9); color: white; }
        .dice-btn.d8 { background: linear-gradient(135deg, #2ecc71, #27ae60); color: white; }
        .dice-btn.d10 { background: linear-gradient(135deg, #f39c12, #d68910); color: white; }
        .dice-btn.d12 { background: linear-gradient(135deg, #9b59b6, #8e44ad); color: white; }
        .dice-btn.d20 { background: linear-gradient(135deg, #e94560, #c0392b); color: white; }
        .dice-btn.d100 { background: linear-gradient(135deg, #1abc9c, #16a085); color: white; }
        .dice-icon { font-size: 1.4rem; margin-bottom: 2px; }
        .dice-result-area {
            min-height: 120px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
        }
        .dice-rolling {
            font-size: 4rem;
            font-weight: bold;
            color: #ffc107;
            animation: diceShake 0.1s infinite;
        }
        .dice-result {
            font-size: 5rem;
            font-weight: bold;
            color: #4ecdc4;
            text-shadow: 0 0 20px rgba(78, 205, 196, 0.5);
            animation: diceReveal 0.3s ease-out;
        }
        .dice-result-label {
            font-size: 1rem;
            color: #888;
            margin-top: 5px;
        }
        @keyframes diceShake {
            0%, 100% { transform: rotate(-5deg); }
            50% { transform: rotate(5deg); }
        }
        @keyframes diceReveal {
            from { transform: scale(0.5); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }
        .dice-history {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #333;
            max-height: 100px;
            overflow-y: auto;
        }
        .dice-history-item {
            font-size: 0.8rem;
            color: #888;
            padding: 3px 0;
        }
        .dice-history-item .player { color: #4ecdc4; }
        .dice-history-item .result { color: #ffc107; font-weight: bold; }

        /* ===== STARTING PLAYER SELECTION ===== */
        .start-selection-modal {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.95);
            z-index: 4000;
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
        }
        .start-selection-modal.show { display: flex; }
        .start-selection-container {
            text-align: center;
            padding: 30px;
        }
        .start-selection-title {
            font-size: 1.5rem;
            color: #e94560;
            margin-bottom: 30px;
        }
        .start-selection-wheel {
            position: relative;
            width: 300px;
            height: 300px;
            margin: 0 auto 30px;
        }
        .wheel-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80px;
            height: 80px;
            background: #16213e;
            border-radius: 50%;
            border: 3px solid #e94560;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            font-size: 2rem;
        }
        .wheel-player {
            position: absolute;
            width: 70px;
            height: 70px;
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            font-weight: bold;
            transition: all 0.3s;
            border: 3px solid transparent;
        }
        .wheel-player.rolling {
            animation: playerPulse 0.2s infinite;
        }
        .wheel-player.winner {
            border-color: #ffc107;
            box-shadow: 0 0 30px rgba(255, 193, 7, 0.8);
            transform: scale(1.2);
        }
        .wheel-player .roll-value {
            font-size: 1.2rem;
            margin-top: 3px;
        }
        @keyframes playerPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        .start-btn {
            padding: 15px 40px;
            font-size: 1.1rem;
            background: linear-gradient(135deg, #e94560, #c0392b);
            color: white;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .start-btn:hover { transform: scale(1.05); box-shadow: 0 0 20px rgba(233, 69, 96, 0.5); }
        .start-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .start-result {
            margin-top: 20px;
            font-size: 1.3rem;
            color: #ffc107;
            animation: fadeIn 0.5s;
        }

        /* ===== RESPONSIVE LAYOUTS ===== */
        /* Medium screens (laptops, smaller monitors) */
        @media (max-height: 800px) {
            .game-container { gap: 2px; padding: 2px; }
            .game-header { padding: 4px 8px; }
            .turn-info { font-size: 0.8rem; gap: 6px; }
            .game-controls button { padding: 3px 7px; font-size: 0.75rem; }

            .phase-tracker { padding: 3px 6px; }
            .phase-btn { padding: 3px 5px; font-size: 0.65rem; }
            .phase-next-btn { padding: 3px 10px; font-size: 0.7rem; }
            .phase-separator { height: 16px; }

            .player-area { padding: 4px; }
            .player-header { gap: 5px; padding-bottom: 2px; margin-bottom: 2px; }
            .player-avatar { width: 24px; height: 24px; font-size: 0.75rem; }
            .player-info .name { font-size: 0.75rem; }
            .player-info .stats { font-size: 0.65rem; gap: 5px; }
            .commander-link { font-size: 0.6rem; max-width: 130px; }
            .player-life .life { font-size: 0.95rem; min-width: 26px; }
            .player-life button { width: 17px; height: 17px; font-size: 0.75rem; }
            .generic-counter { width: 17px; height: 17px; font-size: 0.6rem; }
            .mini-zone { font-size: 0.6rem; padding: 2px 4px; }

            .battlefield-row { min-height: 55px; padding: 4px 6px; }
            .cards-container { gap: 5px; min-height: 45px; }

            .card { width: 72px; height: 100px; }
            .card.tapped { margin: 10px 14px; }
            .card .counters { font-size: 0.45rem; }

            .game-container { padding-right: 65px; }
            .my-zones-row { gap: 6px; padding: 8px 6px; right: 5px; }
            .stack-visual { width: 38px; height: 53px; }
            .card-back { width: 38px; height: 53px; }
            .zone-count { font-size: 0.8rem; }
            .zone-label { font-size: 0.5rem; }
            .graveyard-zone .top-card, .exile-zone .top-card { width: 38px; height: 53px; }
            .command-zone-stack { min-height: 55px; padding: 3px; min-width: 44px; }
            .command-zone-stack .card { width: 38px; height: 53px; }

            .my-hand-container { padding: 5px; }
            .my-hand-container h3 { font-size: 0.7rem; margin-bottom: 3px; }
            .hand-cards .card { width: 68px; height: 95px; }
            .hand-cards .card:hover { transform: translateY(-6px) scale(1.03); }
        }

        /* Small screens (small laptops, tablets) */
        @media (max-height: 700px) {
            .game-header { padding: 3px 6px; }
            .turn-info { font-size: 0.7rem; }
            .connection-status { font-size: 0.65rem; }
            .connection-dot { width: 6px; height: 6px; }

            .phase-tracker { padding: 2px 5px; gap: 1px; }
            .phase-btn { padding: 2px 4px; font-size: 0.6rem; }
            .phase-group-label { font-size: 0.5rem; }
            .phase-next-btn { padding: 3px 8px; font-size: 0.65rem; margin-left: 5px; }
            .phase-separator { height: 14px; margin: 0 3px; }

            .player-area { padding: 3px; border-radius: 4px; }
            .player-header { gap: 4px; padding-bottom: 2px; margin-bottom: 2px; }
            .player-avatar { width: 20px; height: 20px; font-size: 0.65rem; }
            .player-info .name { font-size: 0.65rem; }
            .player-info .stats { font-size: 0.55rem; gap: 4px; }
            .commander-link { font-size: 0.55rem; max-width: 110px; }
            .player-life .life { font-size: 0.85rem; min-width: 22px; }
            .player-life button { width: 15px; height: 15px; font-size: 0.65rem; }
            .player-life-counters { gap: 4px; }
            .generic-counters { gap: 2px; }
            .generic-counter { width: 15px; height: 15px; font-size: 0.55rem; }
            .mini-zone { font-size: 0.55rem; padding: 2px 3px; }
            .player-zones-mini { gap: 3px; }

            .battlefield-row { min-height: 45px; padding: 3px 5px; }
            .cards-container { gap: 4px; min-height: 38px; }

            .card { width: 62px; height: 87px; border-radius: 4px; }
            .card.tapped { margin: 8px 12px; }
            .card .counters { font-size: 0.4rem; padding: 1px 2px; }

            .game-container { padding-right: 55px; }
            .my-zones-row { gap: 5px; padding: 6px 5px; right: 3px; }
            .stack-visual { width: 32px; height: 45px; }
            .card-back { width: 32px; height: 45px; }
            .card-back.offset-1 { top: 1px; left: 1px; }
            .card-back.offset-2 { top: 2px; left: 2px; }
            .zone-count { font-size: 0.7rem; }
            .zone-label { font-size: 0.45rem; margin-top: 1px; }
            .graveyard-zone .top-card, .exile-zone .top-card { width: 32px; height: 45px; }
            .command-zone-stack { min-height: 48px; min-width: 38px; }
            .command-zone-stack .card { width: 32px; height: 45px; }

            .my-hand-container { padding: 4px; border-top-width: 2px; }
            .my-hand-container h3 { font-size: 0.65rem; }
            .hand-cards { gap: 2px; }
            .hand-cards .card { width: 56px; height: 78px; }
            .hand-cards .card:hover { transform: translateY(-5px) scale(1.02); }
        }

        /* Very small screens */
        @media (max-height: 600px) {
            .game-container { gap: 1px; padding: 1px; }
            .game-header { padding: 2px 5px; border-radius: 3px; }
            .turn-info { font-size: 0.6rem; }
            .game-controls button { padding: 2px 5px; font-size: 0.65rem; }

            .phase-tracker { border-radius: 3px; }
            .phase-btn { padding: 2px 3px; font-size: 0.55rem; border-radius: 2px; }
            .phase-next-btn { padding: 2px 6px; font-size: 0.6rem; }

            .player-area { border-radius: 3px; border-width: 1px; }
            .player-header { border-bottom: none; }
            .player-avatar { width: 18px; height: 18px; font-size: 0.6rem; }
            .player-info .name { font-size: 0.6rem; }
            .player-info .stats { font-size: 0.5rem; }
            .commander-link { display: none; }
            .player-life .life { font-size: 0.75rem; min-width: 20px; }
            .player-life button { width: 14px; height: 14px; font-size: 0.55rem; }
            .generic-counter { width: 13px; height: 13px; font-size: 0.5rem; }
            .mini-zone { font-size: 0.5rem; }

            .battlefield-row { min-height: 38px; padding: 2px 4px; border-radius: 3px; }
            .cards-container { min-height: 32px; }

            .card { width: 52px; height: 73px; }
            .card.tapped { margin: 6px 10px; }
            .card .counters { font-size: 0.35rem; }

            .game-container { padding-right: 48px; }
            .my-zones-row { gap: 4px; padding: 5px 4px; border-radius: 4px; right: 2px; }
            .stack-visual { width: 28px; height: 39px; }
            .card-back { width: 28px; height: 39px; border-width: 1px; }
            .zone-count { font-size: 0.6rem; }
            .zone-label { font-size: 0.4rem; }
            .graveyard-zone .top-card, .exile-zone .top-card { width: 28px; height: 39px; }
            .command-zone-stack { min-height: 42px; min-width: 34px; border-width: 1px; }
            .command-zone-stack .card { width: 28px; height: 39px; }

            .my-hand-container { padding: 3px; border-radius: 3px 3px 0 0; }
            .my-hand-container h3 { font-size: 0.6rem; }
            .hand-cards .card { width: 48px; height: 67px; }
            .hand-cards .card:hover { transform: translateY(-3px); }
        }

        /* Width-based adjustments for narrow screens */
        @media (max-width: 1200px) {
            .sidebar { width: 200px; }
        }

        @media (max-width: 900px) {
            .players-grid[data-players="4"] { grid-template-columns: 1fr 1fr; }
            .players-grid[data-players="5"] { grid-template-columns: 1fr 1fr; grid-template-rows: repeat(3, 1fr); }
            .players-grid[data-players="6"] { grid-template-columns: 1fr 1fr; grid-template-rows: repeat(3, 1fr); }
            .players-grid[data-players="7"] { grid-template-columns: 1fr 1fr; grid-template-rows: repeat(4, 1fr); }
            .players-grid[data-players="8"] { grid-template-columns: 1fr 1fr; grid-template-rows: repeat(4, 1fr); }

            .sidebar { width: 180px; }
            .chat-panel { max-height: 100px; }
        }

        /* Compact mode for both small height AND width */
        @media (max-height: 700px) and (max-width: 1200px) {
            .card { width: 54px; height: 76px; }
            .card.tapped { margin: 6px 10px; }
            .hand-cards .card { width: 52px; height: 73px; }
        }
    </style>
</head>
<body>
    <div id="loadingOverlay" class="loading-overlay">
        <div class="spinner"></div>
    </div>

    <button class="sidebar-toggle" onclick="toggleSidebar()">Chat/Log</button>

    <div class="sidebar" id="sidebar">
        <button class="sidebar-close" onclick="toggleSidebar()">&times;</button>
        <div class="chat-panel">
            <h3>Chat</h3>
            <div class="chat-messages" id="chatMessages"></div>
            <div class="chat-input-container">
                <input type="text" id="chatInput" placeholder="Mensagem..." onkeypress="if(event.key==='Enter') sendChat()">
                <button onclick="sendChat()">Enviar</button>
            </div>
        </div>
        <div class="log-panel">
            <h3>Log</h3>
            <div id="actionLog"></div>
        </div>
    </div>

    <!-- SVG for Arrows -->
    <svg class="arrows-svg" id="arrowsSvg" style="pointer-events: none;">
        <defs>
            <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                <polygon points="0 0, 10 3.5, 0 7" fill="#e94560" />
            </marker>
        </defs>
    </svg>

    <div class="game-container" id="gameContainer" style="display: none;">
        <div class="game-header">
            <div class="turn-info">
                <span class="turn" id="turnNumber">Turno 1</span>
                <span class="active" id="activePlayer">Vez de: -</span>
            </div>
            <div class="connection-status">
                <div class="connection-dot" id="connectionDot"></div>
                <span id="connectionText">Conectando...</span>
            </div>
            <div class="game-controls">
                <button onclick="drawCard()" title="D">Comprar</button>
                <button onclick="nextTurn()" class="primary" title="P">Passar Turno</button>
                <button onclick="showStartSelection()" title="Sortear inicio"></button>
                <button onclick="openDiceModal()" title="Dados (R)"></button>
                <button onclick="toggleFullscreen()" title="Tela cheia (F11)" id="fullscreenBtn"></button>
                <button onclick="if(confirm('Conceder?')) sendAction('concede')" style="background:#c0392b;">Conceder</button>
            </div>
        </div>

        <!-- Phase Tracker -->
        <div class="phase-tracker" id="phaseTracker">
            <div class="phase-group">
                <span class="phase-group-label">Inicio</span>
                <button class="phase-btn" data-phase="untap" onclick="goToPhase('untap')">Desvirar</button>
                <button class="phase-btn" data-phase="upkeep" onclick="goToPhase('upkeep')">Manutencao</button>
                <button class="phase-btn" data-phase="draw" onclick="goToPhase('draw')">Compra</button>
            </div>
            <div class="phase-separator"></div>
            <div class="phase-group">
                <span class="phase-group-label">Main1</span>
                <button class="phase-btn" data-phase="main1" onclick="goToPhase('main1')">Principal 1</button>
            </div>
            <div class="phase-separator"></div>
            <div class="phase-group">
                <span class="phase-group-label">Combate</span>
                <button class="phase-btn" data-phase="combat_begin" onclick="goToPhase('combat_begin')">Inicio</button>
                <button class="phase-btn" data-phase="combat_attackers" onclick="goToPhase('combat_attackers')">Atacantes</button>
                <button class="phase-btn" data-phase="combat_blockers" onclick="goToPhase('combat_blockers')">Bloqueadores</button>
                <button class="phase-btn" data-phase="combat_damage" onclick="goToPhase('combat_damage')">Dano</button>
                <button class="phase-btn" data-phase="combat_end" onclick="goToPhase('combat_end')">Fim</button>
            </div>
            <div class="phase-separator"></div>
            <div class="phase-group">
                <span class="phase-group-label">Main2</span>
                <button class="phase-btn" data-phase="main2" onclick="goToPhase('main2')">Principal 2</button>
            </div>
            <div class="phase-separator"></div>
            <div class="phase-group">
                <span class="phase-group-label">Final</span>
                <button class="phase-btn" data-phase="end" onclick="goToPhase('end')">Etapa Final</button>
                <button class="phase-btn" data-phase="cleanup" onclick="goToPhase('cleanup')">Limpeza</button>
            </div>
            <button class="phase-next-btn" onclick="nextPhase()" title="N">Proxima Fase &rarr;</button>
        </div>

        <!-- Dynamic Players Grid -->
        <div class="players-grid" id="playersGrid"></div>

        <!-- Bottom Zones Row -->
        <div class="my-zones-row">
            <div class="zone-stack library-zone" id="myLibrary"
                 onclick="showLibraryMenu()" oncontextmenu="showLibraryContextMenu(event); return false;">
                <div class="stack-visual">
                    <div class="card-back"></div>
                    <div class="card-back offset-1"></div>
                    <div class="card-back offset-2"></div>
                </div>
                <span class="zone-count" id="libraryCount">0</span>
                <span class="zone-label">Biblioteca</span>
            </div>
            <div class="zone-stack graveyard-zone" id="myGraveyard"
                 onclick="showZoneViewer('graveyard')"
                 ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)"
                 ondrop="handleDropToMyZone(event, 'graveyard')">
                <div class="top-card" id="graveyardTopCard"></div>
                <span class="zone-count" id="graveyardCount">0</span>
                <span class="zone-label">Cemiterio</span>
            </div>
            <div class="zone-stack exile-zone" id="myExile"
                 onclick="showZoneViewer('exile')"
                 ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)"
                 ondrop="handleDropToMyZone(event, 'exile')">
                <div class="top-card" id="exileTopCard"></div>
                <span class="zone-count" id="exileCount">0</span>
                <span class="zone-label">Exilio</span>
            </div>
            <div class="command-zone-stack" id="myCommandZone"
                 ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)"
                 ondrop="handleDropToMyZone(event, 'command')">
                <div class="commanders-container" id="commanderCards"></div>
                <span class="zone-label">Comando</span>
            </div>
        </div>

    </div>

    <!-- Hand Toggle Button -->
    <button class="hand-toggle-btn" id="handToggleBtn" onclick="toggleHand()"
            ondragover="handleToggleBtnDragOver(event)"
            ondragleave="handleToggleBtnDragLeave(event)"
            ondrop="handleDropToHand(event)">
        Mao (<span id="handCountToggle">0</span>) 
    </button>

    <!-- My Hand (Floating) -->
    <div class="my-hand-container" id="myHandContainer"
         ondragover="handleHandDragOver(event)" ondragleave="handleHandDragLeave(event)"
         ondrop="handleDropToHand(event)"
         oncontextmenu="showHandZoneContextMenu(event); return false;">
        <div class="my-hand-header">
            <h3>Sua Mao (<span id="handCount">0</span>)</h3>
            <button class="hand-close-btn" onclick="toggleHand()">Fechar </button>
        </div>
        <div class="hand-cards" id="myHand"></div>
    </div>

    <!-- Fullscreen Prompt -->
    <div class="fullscreen-prompt" id="fullscreenPrompt" style="display: none;">
        <h2>Modo Tela Cheia</h2>
        <p>Para uma melhor experiencia de jogo, recomendamos usar o modo tela cheia. Isso permite ver mais cartas no campo de batalha.</p>
        <button class="btn-fullscreen" onclick="enterFullscreen()">Entrar em Tela Cheia</button>
        <button class="btn-skip" onclick="skipFullscreen()">Continuar assim</button>
    </div>

    <!-- Selection Box -->
    <div class="selection-box" id="selectionBox"></div>

    <!-- Context Menu -->
    <div class="context-menu" id="contextMenu">
        <div id="contextMenuItems"></div>
    </div>

    <!-- Zone Viewer Modal -->
    <div class="modal-overlay" id="zoneViewerModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="zoneViewerTitle">Zona</h3>
                <div style="display: flex; gap: 8px;">
                    <button id="exileAllGraveyardBtn" onclick="exileAllFromGraveyard()" style="background: #9b59b6; display: none;">Exilar Tudo</button>
                    <button onclick="closeZoneViewer()">Fechar</button>
                </div>
            </div>
            <p style="font-size: 0.7rem; color: #888; text-align: center; margin-bottom: 8px;">Shift+clique para selecionar | Arraste para mover</p>
            <div class="modal-cards" id="zoneViewerCards"></div>
            <div class="zone-viewer-actions" id="zoneViewerActions" style="display: none;">
                <span class="selection-count" id="zoneSelectionCount">0 selecionadas</span>
                <button onclick="moveZoneSelectionTo('hand')">Mover para Mo</button>
                <button onclick="moveZoneSelectionTo('battlefield')">Mover para Campo</button>
                <button onclick="clearZoneSelection()">Limpar Seleo</button>
            </div>
        </div>
    </div>

    <!-- Mulligan Modal -->
    <div class="mulligan-modal" id="mulliganModal">
        <h3>Mulligan</h3>
        <p id="mulliganInstructions">Selecione as cartas para devolver ao topo da biblioteca</p>
        <div class="mulligan-cards" id="mulliganCards"></div>
        <div class="mulligan-info">
            <span class="mulligan-count" id="mulliganSelectionCount">0 / 1 selecionadas</span>
            <button class="confirm" id="mulliganConfirmBtn" onclick="confirmMulligan()" disabled>Confirmar</button>
        </div>
    </div>

    <!-- Library Viewer Modal -->
    <div class="modal-overlay" id="libraryViewerModal">
        <div class="modal-content" style="max-width: 85vw;">
            <div class="modal-header">
                <h3 id="libraryViewerTitle">Sua Biblioteca</h3>
                <span style="font-size:0.7rem;color:#888;">(Clique em uma carta para mover | Sera embaralhada ao fechar)</span>
                <button onclick="closeLibraryViewer()">Fechar e Embaralhar</button>
            </div>
            <div class="library-viewer-cards" id="libraryViewerCards"></div>
        </div>
    </div>

    <!-- Scry Modal -->
    <div class="scry-modal" id="scryModal">
        <div class="scry-content">
            <h3 id="scryTitle">Videncia</h3>
            <div class="scry-cards" id="scryCards"></div>
            <div class="scry-zones">
                <div class="scry-zone" id="scryTop"
                     ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)"
                     ondrop="handleScryDrop(event, 'top')">
                    <span>Topo</span>
                    <div class="scry-cards-list" id="scryTopCards"></div>
                </div>
                <div class="scry-zone" id="scryBottom"
                     ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)"
                     ondrop="handleScryDrop(event, 'bottom')">
                    <span>Fundo</span>
                    <div class="scry-cards-list" id="scryBottomCards"></div>
                </div>
            </div>
            <button class="btn primary" onclick="confirmScry()">Confirmar</button>
            <button class="btn" style="background:#333;color:white;margin-left:6px;" onclick="closeScryModal()">Cancelar</button>
        </div>
    </div>

    <!-- Reveal Overlay -->
    <div class="reveal-overlay" id="revealOverlay">
        <img id="revealedCardImage" src="" alt="">
        <p id="revealedCardText"></p>
    </div>

    <!-- Card Modal -->
    <div class="card-modal" id="cardModal">
        <img id="modalImage" src="" alt="">
        <div class="actions" id="modalActions"></div>
    </div>

    <!-- Winner Overlay -->
    <div class="winner-overlay" id="winnerOverlay">
        <h1 id="winnerText">Vencedor!</h1>
        <a id="lobbyLink" href="/lobby/">Voltar ao Lobby</a>
    </div>

    <!-- Counter Adjustment Modal -->
    <div class="modal-overlay" id="counterModal">
        <div class="modal-content" style="text-align:center;min-width:200px;">
            <div class="modal-header">
                <h3 id="counterModalTitle">Marcador</h3>
                <button onclick="closeCounterModal()">Fechar</button>
            </div>
            <div style="display:flex;align-items:center;justify-content:center;gap:15px;margin:15px 0;">
                <button onclick="adjustCounter(-1)" style="width:40px;height:40px;font-size:1.5rem;border:none;background:#e94560;color:white;border-radius:50%;cursor:pointer;">-</button>
                <span id="counterValue" style="font-size:2rem;font-weight:bold;min-width:50px;">0</span>
                <button onclick="adjustCounter(1)" style="width:40px;height:40px;font-size:1.5rem;border:none;background:#4ecdc4;color:white;border-radius:50%;cursor:pointer;">+</button>
            </div>
        </div>
    </div>

    <!-- Auto-Pay Mana Modal -->
    <div class="autopay-modal" id="autopayModal">
        <div class="autopay-content">
            <div class="autopay-header">
                <h3>Auto-Pay Mana <span class="autopay-beta"> BETA</span></h3>
                <button onclick="closeAutopayModal()">Fechar</button>
            </div>
            <div class="autopay-card-preview">
                <img id="autopayCardImage" src="" alt="Card">
                <div class="autopay-cost-info">
                    <h4 id="autopayCardName">Nome da Carta</h4>
                    <div>Custo de Mana:</div>
                    <div class="autopay-mana-cost" id="autopayManaCost"></div>
                    <div style="font-size:0.7rem;color:#888;margin-top:5px;">
                        Esta funcionalidade esta em fase de testes e pode conter bugs.
                    </div>
                </div>
            </div>
            <div id="autopayMultiSelect" class="autopay-multi-select" style="display:none;">
                <h5>Selecione a cor de mana para: <span id="autopayMultiLandName"></span></h5>
                <div class="multi-mana-options" id="autopayMultiOptions"></div>
            </div>
            <div class="autopay-lands-section">
                <h4>Terrenos e Fontes de Mana Disponiveis (nao virados):</h4>
                <div class="autopay-lands-grid" id="autopayLandsGrid"></div>
            </div>
            <div class="autopay-status" id="autopayStatus">Calculando mana necessaria...</div>
            <div class="autopay-actions">
                <button class="cancel" onclick="closeAutopayModal()">Cancelar</button>
                <button class="confirm" id="autopayConfirmBtn" onclick="confirmAutopay()" disabled>Jogar com Auto-Pay</button>
            </div>
        </div>
    </div>

    <!-- Help Buttons -->
    <div class="help-buttons">
        <button class="help-btn guide" onclick="openGuideModal()" title="Guia (H)">?</button>
        <button class="help-btn keywords" onclick="openKeywordsModal()" title="Keywords (K)">K</button>
        <button class="help-btn dice" onclick="openDiceModal()" title="Dados (R)"></button>
    </div>

    <!-- Dice Roller Modal -->
    <div class="dice-modal" id="diceModal">
        <div class="dice-container">
            <h2> Rolar Dados</h2>
            <div class="dice-buttons">
                <button class="dice-btn d4" onclick="rollDice(4)">
                    <span class="dice-icon"></span>
                    <span>d4</span>
                </button>
                <button class="dice-btn d6" onclick="rollDice(6)">
                    <span class="dice-icon"></span>
                    <span>d6</span>
                </button>
                <button class="dice-btn d8" onclick="rollDice(8)">
                    <span class="dice-icon"></span>
                    <span>d8</span>
                </button>
                <button class="dice-btn d10" onclick="rollDice(10)">
                    <span class="dice-icon"></span>
                    <span>d10</span>
                </button>
                <button class="dice-btn d12" onclick="rollDice(12)">
                    <span class="dice-icon"></span>
                    <span>d12</span>
                </button>
                <button class="dice-btn d20" onclick="rollDice(20)">
                    <span class="dice-icon"></span>
                    <span>d20</span>
                </button>
                <button class="dice-btn d100" onclick="rollDice(100)">
                    <span class="dice-icon">%</span>
                    <span>d100</span>
                </button>
            </div>
            <div class="dice-result-area" id="diceResultArea">
                <div style="color:#666;">Clique em um dado para rolar</div>
            </div>
            <div class="dice-history" id="diceHistory"></div>
            <button onclick="closeDiceModal()" style="margin-top:15px;padding:8px 20px;background:#333;border:none;color:white;border-radius:5px;cursor:pointer;">Fechar</button>
        </div>
    </div>

    <!-- Starting Player Selection Modal -->
    <div class="start-selection-modal" id="startSelectionModal">
        <div class="start-selection-container">
            <h2 class="start-selection-title"> Quem Comeca?</h2>
            <p style="color:#888;margin-bottom:20px;">Cada jogador rola um d20. O maior resultado comeca!</p>
            <div class="start-selection-wheel" id="startSelectionWheel"></div>
            <button class="start-btn" id="startRollBtn" onclick="startRollForFirst()">
                 Rolar para Decidir
            </button>
            <div class="start-result" id="startResult" style="display:none;"></div>
        </div>
    </div>

    <!-- User Guide Modal -->
    <div class="help-modal" id="guideModal">
        <div class="help-content">
            <div class="help-header">
                <h2>Guia do Jogador - MTG Commander</h2>
                <button class="close-btn" onclick="closeGuideModal()">&times;</button>
            </div>
            <div class="help-tabs">
                <button class="help-tab active" onclick="showGuideTab('shortcuts')">Atalhos</button>
                <button class="help-tab" onclick="showGuideTab('actions')">Acoes</button>
                <button class="help-tab" onclick="showGuideTab('phases')">Fases</button>
                <button class="help-tab" onclick="showGuideTab('rules')">Regras</button>
            </div>
            <div class="help-body">
                <!-- Shortcuts Tab -->
                <div id="guideTab-shortcuts" class="guide-tab-content">
                    <div class="help-section">
                        <h3>Atalhos de Teclado</h3>
                        <div class="shortcut-grid">
                            <div class="shortcut-item"><span class="shortcut-key">D</span><span class="shortcut-desc">Comprar carta</span></div>
                            <div class="shortcut-item"><span class="shortcut-key">N</span><span class="shortcut-desc">Proxima fase</span></div>
                            <div class="shortcut-item"><span class="shortcut-key">P</span><span class="shortcut-desc">Passar turno</span></div>
                            <div class="shortcut-item"><span class="shortcut-key">S</span><span class="shortcut-desc">Embaralhar biblioteca</span></div>
                            <div class="shortcut-item"><span class="shortcut-key">G</span><span class="shortcut-desc">Ver cemiterio</span></div>
                            <div class="shortcut-item"><span class="shortcut-key">E</span><span class="shortcut-desc">Ver exilio</span></div>
                            <div class="shortcut-item"><span class="shortcut-key">L</span><span class="shortcut-desc">Menu da biblioteca</span></div>
                            <div class="shortcut-item"><span class="shortcut-key">C</span><span class="shortcut-desc">Abrir/fechar chat</span></div>
                            <div class="shortcut-item"><span class="shortcut-key">X</span><span class="shortcut-desc">Limpar todas setas</span></div>
                            <div class="shortcut-item"><span class="shortcut-key">H</span><span class="shortcut-desc">Este guia</span></div>
                            <div class="shortcut-item"><span class="shortcut-key">K</span><span class="shortcut-desc">Keywords de Magic</span></div>
                            <div class="shortcut-item"><span class="shortcut-key">Esc</span><span class="shortcut-desc">Fechar modais/cancelar</span></div>
                        </div>
                    </div>
                    <div class="help-section">
                        <h3>Acoes do Mouse</h3>
                        <div class="shortcut-grid">
                            <div class="shortcut-item"><span class="shortcut-key">2x</span><span class="shortcut-desc">Virar/desvirar carta</span></div>
                            <div class="shortcut-item"><span class="shortcut-key">Shift+Clique</span><span class="shortcut-desc">Multi-selecao</span></div>
                            <div class="shortcut-item"><span class="shortcut-key">Clique Direito</span><span class="shortcut-desc">Menu de contexto</span></div>
                            <div class="shortcut-item"><span class="shortcut-key">Arrastar</span><span class="shortcut-desc">Mover carta</span></div>
                        </div>
                    </div>
                </div>

                <!-- Actions Tab -->
                <div id="guideTab-actions" class="guide-tab-content" style="display:none;">
                    <div class="help-section">
                        <h3>Como Jogar Cartas</h3>
                        <ul class="help-list">
                            <li><strong>Mao para Campo:</strong> Arraste a carta da mao para uma linha do seu campo, ou clique direito e selecione "Jogar no Campo"</li>
                            <li><strong>Lancar Comandante:</strong> Clique duplo no comandante na zona de comando, ou clique direito e "Lancar"</li>
                            <li><strong>Virar/Desvirar:</strong> Clique duplo na carta no campo, ou selecione varias com Shift e clique duplo</li>
                        </ul>
                    </div>
                    <div class="help-section">
                        <h3>Mover Cartas Entre Zonas</h3>
                        <ul class="help-list">
                            <li><strong>Para Cemiterio:</strong> Arraste para o cemiterio ou clique direito > "Enviar para Cemiterio"</li>
                            <li><strong>Para Exilio:</strong> Arraste para o exilio ou clique direito > "Exilar"</li>
                            <li><strong>Devolver a Mao:</strong> Clique direito > "Devolver a Mao"</li>
                            <li><strong>Zona de Comando:</strong> Comandantes podem voltar > "Devolver a Zona de Comando"</li>
                        </ul>
                    </div>
                    <div class="help-section">
                        <h3>Setas e Alvos</h3>
                        <ul class="help-list">
                            <li><strong>Criar Seta:</strong> Clique direito na carta > "Criar seta" > clique no alvo (jogador ou carta)</li>
                            <li><strong>Remover Seta:</strong> Clique direito na carta > "Remover seta" ou pressione X para limpar todas</li>
                            <li>Setas podem apontar para jogadores ou outras cartas (uteis para auras, equipamentos, alvos)</li>
                        </ul>
                    </div>
                    <div class="help-section">
                        <h3>Biblioteca (Tutor, Scry)</h3>
                        <ul class="help-list">
                            <li><strong>Ver Biblioteca:</strong> Clique direito na biblioteca > "Ver toda biblioteca"</li>
                            <li><strong>Buscar Carta:</strong> Na visualizacao, clique na carta desejada e escolha onde colocar</li>
                            <li><strong>Videncia (Scry):</strong> Clique direito > "Videncia" > arraste cartas para Topo ou Fundo</li>
                            <li>A biblioteca e embaralhada automaticamente ao fechar a visualizacao</li>
                        </ul>
                    </div>
                </div>

                <!-- Phases Tab -->
                <div id="guideTab-phases" class="guide-tab-content" style="display:none;">
                    <div class="help-section">
                        <h3>Fases do Turno</h3>
                        <ul class="help-list">
                            <li><strong>Desvirar (Untap):</strong> Todas suas permanentes desviram. Nenhum jogador pode fazer acoes.</li>
                            <li><strong>Manutencao (Upkeep):</strong> Habilidades de "no inicio da manutencao" disparam. Jogadores podem responder.</li>
                            <li><strong>Compra (Draw):</strong> Compre uma carta (exceto primeiro turno). Jogadores podem responder apos.</li>
                            <li><strong>Fase Principal 1:</strong> Jogue terrenos, criaturas, feiticos, etc.</li>
                            <li><strong>Inicio do Combate:</strong> Ultima chance de virar criaturas antes de declarar atacantes.</li>
                            <li><strong>Declarar Atacantes:</strong> Escolha quais criaturas atacam e quais jogadores/planeswalkers.</li>
                            <li><strong>Declarar Bloqueadores:</strong> Defensor escolhe bloqueadores.</li>
                            <li><strong>Dano de Combate:</strong> Dano e causado simultaneamente (first strike primeiro).</li>
                            <li><strong>Fim do Combate:</strong> Habilidades de "fim do combate" disparam.</li>
                            <li><strong>Fase Principal 2:</strong> Igual a primeira fase principal.</li>
                            <li><strong>Etapa Final (End):</strong> Habilidades de "no final do turno" disparam.</li>
                            <li><strong>Limpeza (Cleanup):</strong> Descarte ate 7 cartas, remova dano marcado.</li>
                        </ul>
                    </div>
                </div>

                <!-- Rules Tab -->
                <div id="guideTab-rules" class="guide-tab-content" style="display:none;">
                    <div class="help-section">
                        <h3>Regras de Commander</h3>
                        <ul class="help-list">
                            <li><strong>Vida Inicial:</strong> 40 pontos de vida</li>
                            <li><strong>Dano de Comandante:</strong> 21 dano de combate de um mesmo comandante = derrota</li>
                            <li><strong>Veneno:</strong> 10 marcadores de veneno = derrota</li>
                            <li><strong>Biblioteca Vazia:</strong> Comprar de biblioteca vazia = derrota</li>
                            <li><strong>Taxa de Comandante:</strong> +2 mana para cada vez que lancou o comandante</li>
                            <li><strong>Identidade de Cor:</strong> Deck so pode ter cartas da identidade de cor do comandante</li>
                        </ul>
                    </div>
                    <div class="help-section">
                        <h3>Marcadores Coloridos</h3>
                        <ul class="help-list">
                            <li><strong>Vermelho:</strong> Sugestao: Dano de comandante recebido</li>
                            <li><strong>Azul:</strong> Sugestao: Contador de experiencia</li>
                            <li><strong>Verde:</strong> Sugestao: Marcador de energia</li>
                            <li><strong>Amarelo:</strong> Sugestao: Tesouro/Mana flutuante</li>
                            <li><strong>Roxo:</strong> Sugestao: Contador generico</li>
                            <li>Use como preferir! Clique para ajustar o valor.</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Keywords Modal -->
    <div class="help-modal" id="keywordsModal">
        <div class="help-content" style="max-width: 1000px;">
            <div class="help-header">
                <h2>Keywords de Magic: The Gathering</h2>
                <button class="close-btn" onclick="closeKeywordsModal()">&times;</button>
            </div>
            <div class="keywords-search">
                <input type="text" id="keywordSearch" placeholder="Buscar keyword... (ex: flying, trample, hexproof)" oninput="filterKeywords()">
                <div class="keywords-categories">
                    <button class="category-filter active" onclick="filterByCategory('all')">Todas</button>
                    <button class="category-filter" onclick="filterByCategory('evergreen')">Evergreen</button>
                    <button class="category-filter" onclick="filterByCategory('evasion')">Evasao</button>
                    <button class="category-filter" onclick="filterByCategory('combat')">Combate</button>
                    <button class="category-filter" onclick="filterByCategory('protection')">Protecao</button>
                    <button class="category-filter" onclick="filterByCategory('triggered')">Gatilhos</button>
                    <button class="category-filter" onclick="filterByCategory('static')">Estaticas</button>
                    <button class="category-filter" onclick="filterByCategory('mana')">Mana</button>
                    <button class="category-filter" onclick="filterByCategory('counter')">Marcadores</button>
                </div>
            </div>
            <div class="help-body" id="keywordsBody">
                <div class="keywords-grid" id="keywordsGrid"></div>
                <div class="keywords-count" id="keywordsCount"></div>
            </div>
        </div>
    </div>

    <script>
        // ===== CONSTANTS =====
        const gameId = '{{ game.id }}';
        const myPlayerId = '{{ player.id }}';
        const mySeat = {{ game_player.seat_position }};
        const myNickname = '{{ player.nickname }}';
        const csrfToken = '{{ csrf_token }}';
        const tabId = '{{ tab_id|default:"" }}';

        const PHASES = ['untap', 'upkeep', 'draw', 'main1', 'combat_begin', 'combat_attackers',
                        'combat_blockers', 'combat_damage', 'combat_end', 'main2', 'end', 'cleanup'];

        // ===== STATE =====
        let socket = null;
        let gameState = null;
        let selectedCard = null;
        let selectedCards = new Set();
        let reconnectAttempts = 0;
        const maxReconnectAttempts = 5;
        let draggedCard = null;
        let draggedCardData = null;
        let draggedCards = new Set(); // Multiple cards being dragged
        let handCardOrder = []; // Local order of cards in hand (client-side only)
        let handDragTarget = null; // Target card during hand reorder drag
        let scryCardsData = [];
        let isSelecting = false;
        let selectionStart = { x: 0, y: 0 };

        // Arrow state
        let arrowMode = false;
        let arrowSourceCards = new Set(); // Multiple source cards
        let arrowPreviewPos = null; // {x, y} - mouse position during arrow mode
        let lastMousePos = { x: 0, y: 0 }; // Always track last mouse position
        let arrows = []; // {sourceCardId, targetType: 'player'|'card'|'position', targetId: seatNumber|cardId, targetX, targetY}

        // Global mouse tracker (always active)
        document.addEventListener('mousemove', (e) => {
            lastMousePos = { x: e.clientX, y: e.clientY };
        });

        // Counter modal state
        let counterModalData = { seat: null, color: null };

        // Player counters (local state for generic counters)
        let playerCounters = {}; // seat -> {red: 0, blue: 0, green: 0, yellow: 0, purple: 0}

        // Mulligan state
        let mulliganCount = 0;
        let mulliganPending = 0; // Cards to put back after mulligan

        // Card stacking (synced via WebSocket for visual organization)
        // seatStacks[seat] = { cardStacks: Map<stackId, {cards, topCardId}>, cardToStack: Map<cardId, stackId> }
        let seatStacks = {}; // seat -> { cardStacks, cardToStack, nextStackId }
        // Helper to get/create stack data for a seat
        function getSeatStackData(seat) {
            if (!seatStacks[seat]) {
                seatStacks[seat] = {
                    cardStacks: new Map(),
                    cardToStack: new Map(),
                    nextStackId: 1
                };
            }
            return seatStacks[seat];
        }
        // Shortcut for local player's stacks
        function getMyStackData() {
            return getSeatStackData(mySeat);
        }
        // Legacy compatibility - these reference my seat's data
        let cardStacks, cardToStack, nextStackId;
        function updateLocalStackRefs() {
            const data = getMyStackData();
            cardStacks = data.cardStacks;
            cardToStack = data.cardToStack;
            nextStackId = data.nextStackId;
        }

        // ===== WEBSOCKET =====
        function connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const params = new URLSearchParams();
            if (tabId) params.set('tab', tabId);
            params.set('player_id', myPlayerId);
            const wsUrl = `${protocol}//${window.location.host}/ws/game/${gameId}/?${params.toString()}`;
            socket = new WebSocket(wsUrl);

            socket.onopen = function() {
                reconnectAttempts = 0;
                updateConnectionStatus(true);
                socket.send(JSON.stringify({ action: 'get_state' }));
            };

            socket.onclose = function() {
                updateConnectionStatus(false);
                if (reconnectAttempts < maxReconnectAttempts) {
                    reconnectAttempts++;
                    setTimeout(connectWebSocket, 2000 * reconnectAttempts);
                }
            };

            socket.onerror = function() { updateConnectionStatus(false); };
            socket.onmessage = function(e) { handleMessage(JSON.parse(e.data)); };
        }

        function updateConnectionStatus(connected) {
            const dot = document.getElementById('connectionDot');
            const text = document.getElementById('connectionText');
            dot.classList.toggle('connected', connected);
            text.textContent = connected ? 'Conectado' : 'Desconectado';
        }

        function handleMessage(data) {
            switch (data.type) {
                case 'game_state':
                    gameState = data.state;
                    renderGame();
                    // Clear pending local actions after render - optimistic updates already happened
                    pendingTaps.clear();
                    pendingRowChanges.clear();
                    // Clear confirmed removals (cards that are no longer in game state)
                    pendingRemovals.forEach(cardId => {
                        if (!findCardById(cardId)) {
                            pendingRemovals.delete(cardId);
                        }
                    });
                    // Clear confirmed additions (cards that are now on battlefield)
                    pendingAdditions.forEach((data, cardId) => {
                        if (findCardZone(cardId) === 'battlefield') {
                            pendingAdditions.delete(cardId);
                        }
                    });
                    break;
                case 'chat':
                    addChatMessage(data.sender, data.message);
                    break;
                case 'action_result':
                    if (!data.result.success && !data.result.private) {
                        alert(data.result.error || 'Erro ao executar acao');
                    }
                    break;
                case 'private_action':
                    handlePrivateAction(data);
                    break;
                case 'reveal':
                    showRevealAnimation(data.card);
                    break;
                case 'dice_roll':
                    // Another player rolled dice
                    if (data.player !== myNickname) {
                        addDiceToHistory(data.player, data.sides, data.result);
                        showDiceNotification(data.player, data.sides, data.result);
                    }
                    break;
                case 'starting_player_set':
                    // Starting player was determined
                    if (data.player) {
                        addChatMessage('Sistema', ` ${data.player} foi escolhido para comecar! (rolou ${data.roll})`);
                    }
                    break;
                case 'arrows_update':
                    // Another player created/removed arrows
                    handleArrowsUpdate(data);
                    break;
                case 'stacks_update':
                    // Another player updated their card stacks
                    if (data.seat !== mySeat) {
                        applyRemoteStacks(data.seat, data.stacks);
                    }
                    break;
            }
        }

        function handlePrivateAction(data) {
            if (data.action === 'scry' || data.action === 'look_top') {
                showScryModal(data.data.cards, data.action === 'scry');
            } else if (data.action === 'view_library') {
                showLibraryViewerModal(data.data.cards);
            }
        }

        function sendAction(action, data = {}) {
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({ action, data }));
            } else {
                alert('Conexao perdida. Reconectando...');
                connectWebSocket();
            }
        }

        function sendChat() {
            const input = document.getElementById('chatInput');
            const message = input.value.trim();
            if (message && socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({ action: 'chat', message, sender: myNickname }));
                input.value = '';
            }
        }

        function addChatMessage(sender, message) {
            const container = document.getElementById('chatMessages');
            const div = document.createElement('div');
            div.className = 'chat-message';
            div.innerHTML = `<span class="sender">${sender}:</span> ${message}`;
            container.appendChild(div);
            container.scrollTop = container.scrollHeight;
        }

        function toggleSidebar() {
            document.getElementById('sidebar').classList.toggle('open');
        }

        // ===== FULLSCREEN =====
        let fullscreenPromptShown = false;

        function showFullscreenPrompt() {
            if (fullscreenPromptShown) return;
            if (document.fullscreenElement) return; // Already in fullscreen
            fullscreenPromptShown = true;
            document.getElementById('fullscreenPrompt').style.display = 'flex';
        }

        function enterFullscreen() {
            document.getElementById('fullscreenPrompt').style.display = 'none';
            const elem = document.documentElement;
            if (elem.requestFullscreen) {
                elem.requestFullscreen();
            } else if (elem.webkitRequestFullscreen) {
                elem.webkitRequestFullscreen();
            } else if (elem.msRequestFullscreen) {
                elem.msRequestFullscreen();
            }
        }

        function skipFullscreen() {
            document.getElementById('fullscreenPrompt').style.display = 'none';
        }

        function toggleFullscreen() {
            if (document.fullscreenElement) {
                document.exitFullscreen();
            } else {
                const elem = document.documentElement;
                if (elem.requestFullscreen) {
                    elem.requestFullscreen();
                } else if (elem.webkitRequestFullscreen) {
                    elem.webkitRequestFullscreen();
                } else if (elem.msRequestFullscreen) {
                    elem.msRequestFullscreen();
                }
            }
        }

        // Update fullscreen button icon on change
        document.addEventListener('fullscreenchange', () => {
            const btn = document.getElementById('fullscreenBtn');
            if (btn) {
                btn.textContent = document.fullscreenElement ? '' : '';
                btn.title = document.fullscreenElement ? 'Sair da tela cheia' : 'Tela cheia (F11)';
            }
        });

        // ===== HAND TOGGLE =====
        let handOpen = false;

        function toggleHand() {
            handOpen = !handOpen;
            const container = document.getElementById('myHandContainer');
            const toggleBtn = document.getElementById('handToggleBtn');

            if (handOpen) {
                container.classList.add('show');
                toggleBtn.classList.add('hand-open');
            } else {
                container.classList.remove('show');
                toggleBtn.classList.remove('hand-open');
            }
        }

        function updateHandToggleCount(count) {
            const toggleCount = document.getElementById('handCountToggle');
            if (toggleCount) {
                toggleCount.textContent = count;
            }
        }

        // ===== PHASE SYSTEM =====
        function isMyTurn() {
            return gameState && gameState.active_player_seat === mySeat;
        }

        function showNotMyTurnMessage() {
            const msg = document.createElement('div');
            msg.style.cssText = `
                position: fixed;
                top: 80px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(231, 76, 60, 0.95);
                color: white;
                padding: 10px 20px;
                border-radius: 8px;
                z-index: 5000;
                font-size: 0.9rem;
                animation: fadeIn 0.2s ease-out;
            `;
            msg.textContent = 'Nao e sua vez!';
            document.body.appendChild(msg);
            setTimeout(() => {
                msg.style.animation = 'fadeIn 0.2s ease-out reverse';
                setTimeout(() => msg.remove(), 200);
            }, 1500);
        }

        function goToPhase(phase) {
            if (!isMyTurn()) {
                showNotMyTurnMessage();
                return;
            }
            sendAction('go_to_phase', { phase });
        }

        function nextPhase() {
            if (!isMyTurn()) {
                showNotMyTurnMessage();
                return;
            }
            sendAction('next_phase');
        }

        function nextTurn() {
            if (!isMyTurn()) {
                showNotMyTurnMessage();
                return;
            }
            sendAction('next_turn');
        }

        function drawCard() {
            if (!isMyTurn()) {
                showNotMyTurnMessage();
                return;
            }
            sendAction('draw_card');
        }

        function shuffleLibrary() {
            sendAction('shuffle_library');
            animateShuffle();
        }

        function updatePhaseTracker() {
            if (!gameState) return;
            const currentPhase = gameState.current_phase;
            const currentIdx = PHASES.indexOf(currentPhase);
            const myTurn = isMyTurn();

            // Update phase tracker styling based on whose turn it is
            const tracker = document.getElementById('phaseTracker');
            tracker.classList.toggle('not-my-turn', !myTurn);

            document.querySelectorAll('.phase-btn').forEach(btn => {
                const phase = btn.dataset.phase;
                const phaseIdx = PHASES.indexOf(phase);
                btn.classList.remove('active', 'passed');
                btn.disabled = !myTurn;
                if (phase === currentPhase) {
                    btn.classList.add('active');
                } else if (phaseIdx < currentIdx) {
                    btn.classList.add('passed');
                }
            });

            // Update next phase button
            const nextBtn = document.querySelector('.phase-next-btn');
            if (nextBtn) {
                nextBtn.disabled = !myTurn;
            }
        }

        // ===== RENDER =====
        function renderGame() {
            if (!gameState) return;
            document.getElementById('loadingOverlay').classList.add('hidden');
            document.getElementById('gameContainer').style.display = 'grid';

            // Show fullscreen prompt on first load
            if (!fullscreenPromptShown) {
                setTimeout(showFullscreenPrompt, 500);
            }

            document.getElementById('turnNumber').textContent = `Turno ${gameState.turn_number}`;
            document.getElementById('activePlayer').textContent = `Vez de: ${gameState.active_player_name || '-'}`;

            updatePhaseTracker();

            if (gameState.status === 'finished' && gameState.winner_id) {
                const winner = gameState.players.find(p => p.id === gameState.winner_id);
                if (winner) {
                    document.getElementById('winnerText').textContent = `${winner.nickname} venceu!`;
                    document.getElementById('winnerOverlay').classList.add('show');
                }
            }

            // Initialize player counters if not exists
            gameState.players.forEach(p => {
                if (!playerCounters[p.seat_position]) {
                    playerCounters[p.seat_position] = { red: 0, blue: 0, green: 0, yellow: 0, purple: 0 };
                }
            });

            renderPlayersGrid();
            renderMyZones();
            renderMyHand();
            renderActionLog();
            renderArrows();
        }

        // Generate hash for CARDS ONLY - determines if battlefield needs re-render
        function getCardsHash() {
            const parts = [];
            gameState.players.forEach(player => {
                const zones = gameState.zones_data[player.seat_position];
                if (!zones) return;
                const seat = player.seat_position;

                // Collect all card IDs for this player's battlefield (including pending additions)
                const battlefieldCards = [];

                // Add cards from game state (excluding pending removals)
                (zones.battlefield || []).forEach(card => {
                    if (pendingRemovals.has(card.id)) return;
                    if (pendingAdditions.has(card.id)) return; // Skip, will be added from pendingAdditions
                    const countersStr = card.counters ? Object.entries(card.counters).map(([k,v]) => `${k}${v}`).join('') : '';
                    battlefieldCards.push({ id: card.id, hash: `bf:${seat}:${card.id}:${countersStr}` });
                });

                // Add pending additions for this player
                pendingAdditions.forEach((data, cardId) => {
                    if (data.seat === seat) {
                        battlefieldCards.push({ id: cardId, hash: `bf:${seat}:${cardId}:` });
                    }
                });

                // Sort by card ID to ensure consistent order
                battlefieldCards.sort((a, b) => a.id.localeCompare(b.id));
                battlefieldCards.forEach(c => parts.push(c.hash));

                // Command zone
                (zones.command || []).forEach(card => {
                    parts.push(`cmd:${seat}:${card.id}`);
                });

                // Player alive status
                parts.push(`alive:${seat}:${player.is_alive}`);
            });

            // Include arrow state (affects has-arrow class)
            parts.push(`arr:${[...arrowSourceCards].join(',')}:${arrows.map(a=>`${a.sourceCardId}-${a.targetId || a.targetX}`).join(',')}`);
            return parts.join('|');
        }

        // Surgical update for player headers (life, counters, zone counts) without re-rendering cards
        function updatePlayerHeadersVisual() {
            gameState.players.forEach(player => {
                const zones = gameState.zones_data[player.seat_position];
                if (!zones) return;
                const counters = playerCounters[player.seat_position] || {};
                const playerArea = document.getElementById(`playerArea-${player.seat_position}`);
                if (!playerArea) return;

                // Update life display
                const lifeSpan = playerArea.querySelector('.player-life .life');
                if (lifeSpan) lifeSpan.textContent = player.life;

                // Update zone counts in mini display
                const miniZones = playerArea.querySelectorAll('.mini-zone');
                if (miniZones.length >= 4) {
                    miniZones[0].textContent = zones.library_count;
                    miniZones[1].textContent = zones.hand.length;
                    miniZones[2].textContent = zones.graveyard.length;
                    miniZones[3].textContent = zones.exile.length;
                }

                // Update generic counters
                const counterEls = playerArea.querySelectorAll('.generic-counter');
                if (counterEls.length >= 5) {
                    counterEls[0].textContent = counters.red || '';
                    counterEls[1].textContent = counters.blue || '';
                    counterEls[2].textContent = counters.green || '';
                    counterEls[3].textContent = counters.yellow || '';
                    counterEls[4].textContent = counters.purple || '';
                }

                // Update commander link
                const playerInfo = playerArea.querySelector('.player-info');
                if (playerInfo) {
                    let cmdLink = playerInfo.querySelector('.commander-link');
                    if (zones.command && zones.command.length > 0) {
                        const cmdText = ' ' + zones.command.map(c => c.name).join(' + ');
                        if (cmdLink) {
                            cmdLink.textContent = cmdText;
                        } else {
                            cmdLink = document.createElement('div');
                            cmdLink.className = 'commander-link';
                            cmdLink.textContent = cmdText;
                            cmdLink.title = 'Ver comandante(s)';
                            cmdLink.onclick = (e) => { e.stopPropagation(); showCommanderCards(player.seat_position); };
                            playerInfo.appendChild(cmdLink);
                        }
                    } else if (cmdLink) {
                        cmdLink.remove();
                    }
                }

                // Update active turn indicator
                const isActive = player.seat_position === gameState.active_player_seat;
                playerArea.classList.toggle('active-turn', isActive);
            });
        }

        function renderPlayersGrid(forceRender = false) {
            const container = document.getElementById('playersGrid');
            const playerCount = gameState.players.length;
            container.setAttribute('data-players', playerCount);

            // First render: full render
            if (forceRender || container.children.length === 0) {
                const sortedPlayers = [...gameState.players].sort((a, b) => {
                    if (a.seat_position === mySeat) return 1;
                    if (b.seat_position === mySeat) return -1;
                    return a.seat_position - b.seat_position;
                });

                container.innerHTML = sortedPlayers.map(player => {
                    const isMe = player.seat_position === mySeat;
                    const zones = gameState.zones_data[player.seat_position];
                    const isActive = player.seat_position === gameState.active_player_seat;
                    return renderPlayerArea(player, zones, isMe, isActive);
                }).join('');
                return;
            }

            // Incremental update: only update what changed
            updatePlayerHeadersVisual();
            updateBattlefieldCardsIncremental();
        }

        // Incremental update of battlefield cards - add/remove/update without full re-render
        function updateBattlefieldCardsIncremental() {
            gameState.players.forEach(player => {
                const seat = player.seat_position;
                const isMe = seat === mySeat;
                const zones = gameState.zones_data[seat];
                if (!zones) return;

                // Get cards that should be on battlefield (excluding pending removals, including pending additions)
                const shouldBeOnBattlefield = new Map();
                (zones.battlefield || []).forEach(card => {
                    if (pendingRemovals.has(card.id)) return;
                    if (pendingAdditions.has(card.id)) return; // Will be added from pendingAdditions
                    const row = card.battlefield_row || getCardRow(card.type_line);
                    shouldBeOnBattlefield.set(card.id, { card, row });
                });

                // Add pending additions for this player
                pendingAdditions.forEach((data, cardId) => {
                    if (data.seat === seat) {
                        const row = data.row || getCardRow(data.card.type_line);
                        shouldBeOnBattlefield.set(cardId, { card: data.card, row });
                    }
                });

                // Get cards currently in DOM for this player
                const playerArea = document.getElementById(`playerArea-${seat}`);
                if (!playerArea) return;

                const currentCardsInDom = new Map();
                playerArea.querySelectorAll('.player-battlefield .card').forEach(cardEl => {
                    currentCardsInDom.set(cardEl.dataset.id, cardEl);
                });

                // Remove cards that shouldn't be there
                currentCardsInDom.forEach((cardEl, cardId) => {
                    if (!shouldBeOnBattlefield.has(cardId)) {
                        cardEl.remove();
                    }
                });

                // Add cards that are missing
                shouldBeOnBattlefield.forEach(({ card, row }, cardId) => {
                    if (!currentCardsInDom.has(cardId)) {
                        // Card needs to be added
                        const targetRow = playerArea.querySelector(`.battlefield-row[data-row="${row}"] .cards-container`);
                        if (targetRow) {
                            const cardEl = createBattlefieldCardElement(card, isMe);
                            targetRow.appendChild(cardEl);
                        }
                    } else {
                        // Card exists, update its state (counters, tapped, etc.)
                        const cardEl = currentCardsInDom.get(cardId);
                        updateCardElementState(cardEl, card);
                    }
                });
            });
        }

        // Create a battlefield card DOM element
        function createBattlefieldCardElement(card, isMe) {
            const escapedName = (card.name || '').replace(/&/g, '&amp;').replace(/'/g, '&#39;').replace(/"/g, '&quot;');
            const escapedImage = (card.image_small || card.image_normal || '').replace(/&/g, '&amp;').replace(/'/g, '&#39;').replace(/"/g, '&quot;');
            const isSelected = selectedCards.has(card.id);
            const isArrowSource = arrowSourceCards.has(card.id);
            const hasArrow = arrows.some(a => a.sourceCardId === card.id);

            const cardEl = document.createElement('div');
            cardEl.className = `card ${card.is_tapped ? 'tapped' : ''} ${card.is_commander ? 'commander' : ''} ${isSelected ? 'selected' : ''} ${isArrowSource ? 'arrow-source' : ''} ${hasArrow ? 'has-arrow' : ''}`;
            cardEl.dataset.id = card.id;
            if (isMe) {
                cardEl.draggable = true;
                cardEl.setAttribute('ondragstart', `handleDragStart(event, '${card.id}', 'battlefield')`);
                cardEl.setAttribute('ondragend', `handleBattlefieldDragEnd(event)`);
            }
            cardEl.setAttribute('onclick', `handleBattlefieldCardClick(event, '${card.id}', ${isMe})`);
            if (isMe) {
                cardEl.setAttribute('ondblclick', `event.stopPropagation(); toggleTap('${card.id}')`);
                cardEl.setAttribute('oncontextmenu', `showBattlefieldContextMenuById(event, '${card.id}', true); return false;`);
            } else {
                cardEl.setAttribute('oncontextmenu', `showBattlefieldContextMenuById(event, '${card.id}', false); return false;`);
            }

            // Build innerHTML with counters
            let countersHtml = '';
            if (card.counters && Object.keys(card.counters).length > 0) {
                countersHtml = '<div class="card-counters">' +
                    Object.entries(card.counters).map(([type, count]) =>
                        `<span class="counter ${type}">${count}</span>`
                    ).join('') + '</div>';
            }
            cardEl.innerHTML = `<img src="${escapedImage}" alt="${escapedName}">${countersHtml}`;

            return cardEl;
        }

        // Update an existing card element's state
        function updateCardElementState(cardEl, card) {
            // Update tapped state
            cardEl.classList.toggle('tapped', card.is_tapped || false);

            // Update selection state
            cardEl.classList.toggle('selected', selectedCards.has(card.id));

            // Update arrow states
            cardEl.classList.toggle('arrow-source', arrowSourceCards.has(card.id));
            cardEl.classList.toggle('has-arrow', arrows.some(a => a.sourceCardId === card.id));

            // Update counters
            const existingCounters = cardEl.querySelector('.card-counters');
            const hasCounters = card.counters && Object.keys(card.counters).length > 0;

            if (hasCounters) {
                const countersHtml = '<div class="card-counters">' +
                    Object.entries(card.counters).map(([type, count]) =>
                        `<span class="counter ${type}">${count}</span>`
                    ).join('') + '</div>';

                if (existingCounters) {
                    existingCounters.outerHTML = countersHtml;
                } else {
                    cardEl.insertAdjacentHTML('beforeend', countersHtml);
                }
            } else if (existingCounters) {
                existingCounters.remove();
            }
        }

        function renderPlayerArea(player, zones, isMe, isActive) {
            const classes = ['player-area'];
            if (isMe) classes.push('is-me');
            if (isActive) classes.push('active-turn');
            if (!player.is_alive) classes.push('dead');

            const creatures = [], enchantments = [], lands = [];
            zones.battlefield.forEach(card => {
                const row = card.battlefield_row || getCardRow(card.type_line);
                if (row === 'creatures') creatures.push(card);
                else if (row === 'lands') lands.push(card);
                else enchantments.push(card);
            });

            const counters = playerCounters[player.seat_position] || { red: 0, blue: 0, green: 0, yellow: 0, purple: 0 };

            return `
                <div class="${classes.join(' ')}" data-seat="${player.seat_position}" id="playerArea-${player.seat_position}"
                     ondragover="handlePlayerDragOver(event, ${player.seat_position})"
                     ondragleave="handlePlayerDragLeave(event)"
                     ondrop="handlePlayerDrop(event, ${player.seat_position})"
                     onclick="handlePlayerAreaClick(event, ${player.seat_position})">
                    ${!player.is_alive ? '<div class="dead-overlay">ELIMINADO</div>' : ''}
                    <div class="player-header">
                        <div class="player-avatar" style="background-color: ${player.avatar_color || '#e94560'}"
                             onclick="event.stopPropagation(); startArrowToPlayer(${player.seat_position})"
                             title="Clique para apontar seta">${player.nickname.charAt(0).toUpperCase()}</div>
                        <div class="player-info">
                            <div class="name">${player.nickname}${isMe ? ' (Voce)' : ''}</div>
                            ${zones.command && zones.command.length > 0 ? `
                                <div class="commander-link" onclick="event.stopPropagation(); showCommanderCards(${player.seat_position})" title="Ver comandante(s)">
                                     ${zones.command.map(c => c.name).join(' + ')}
                                </div>
                            ` : ''}
                        </div>
                        <div class="player-life-counters">
                            <div class="player-life">
                                <button onclick="event.stopPropagation(); changeLife(${player.seat_position}, -1)">-</button>
                                <span class="life">${player.life}</span>
                                <button onclick="event.stopPropagation(); changeLife(${player.seat_position}, 1)">+</button>
                            </div>
                            <div class="generic-counters">
                                <div class="generic-counter red" onclick="event.stopPropagation(); openCounterModal(${player.seat_position}, 'red')">${counters.red || ''}</div>
                                <div class="generic-counter blue" onclick="event.stopPropagation(); openCounterModal(${player.seat_position}, 'blue')">${counters.blue || ''}</div>
                                <div class="generic-counter green" onclick="event.stopPropagation(); openCounterModal(${player.seat_position}, 'green')">${counters.green || ''}</div>
                                <div class="generic-counter yellow" onclick="event.stopPropagation(); openCounterModal(${player.seat_position}, 'yellow')">${counters.yellow || ''}</div>
                                <div class="generic-counter purple" onclick="event.stopPropagation(); openCounterModal(${player.seat_position}, 'purple')">${counters.purple || ''}</div>
                            </div>
                        </div>
                        <div class="player-zones-mini">
                            <span class="mini-zone" title="Biblioteca">${zones.library_count}</span>
                            <span class="mini-zone" title="Mao">${zones.hand.length}</span>
                            <span class="mini-zone" title="Cemiterio" onclick="event.stopPropagation(); showOpponentZone(${player.seat_position}, 'graveyard')">${zones.graveyard.length}</span>
                            <span class="mini-zone" title="Exilio" onclick="event.stopPropagation(); showOpponentZone(${player.seat_position}, 'exile')">${zones.exile.length}</span>
                        </div>
                    </div>
                    <div class="player-battlefield">
                        <div class="battlefield-row creatures-row" data-row="creatures" data-seat="${player.seat_position}"
                             ondragover="handleRowDragOver(event)" ondragleave="handleRowDragLeave(event)"
                             ondrop="handleRowDrop(event, ${player.seat_position}, 'creatures')">
                            <div class="cards-container">${renderBattlefieldCards(creatures, isMe, player.seat_position)}</div>
                        </div>
                        <div class="battlefield-row enchantments-row" data-row="enchantments" data-seat="${player.seat_position}"
                             ondragover="handleRowDragOver(event)" ondragleave="handleRowDragLeave(event)"
                             ondrop="handleRowDrop(event, ${player.seat_position}, 'enchantments')">
                            <div class="cards-container">${renderBattlefieldCards(enchantments, isMe, player.seat_position)}</div>
                        </div>
                        <div class="battlefield-row lands-row" data-row="lands" data-seat="${player.seat_position}"
                             ondragover="handleRowDragOver(event)" ondragleave="handleRowDragLeave(event)"
                             ondrop="handleRowDrop(event, ${player.seat_position}, 'lands')">
                            <div class="cards-container">${renderBattlefieldCards(lands, isMe, player.seat_position)}</div>
                        </div>
                    </div>
                </div>
            `;
        }

        function getCardRow(typeLine) {
            if (!typeLine) return 'enchantments';
            const lower = typeLine.toLowerCase();
            if (lower.includes('creature')) return 'creatures';
            if (lower.includes('land')) return 'lands';
            return 'enchantments';
        }

        // Find a card by ID from any zone
        function findCardById(cardId) {
            if (!gameState || !gameState.zones_data) return null;
            for (const seat of Object.keys(gameState.zones_data)) {
                const zones = gameState.zones_data[seat];
                // Check hand
                const handCard = zones.hand?.find(c => c.id === cardId);
                if (handCard) return handCard;
                // Check battlefield
                const bfCard = zones.battlefield?.find(c => c.id === cardId);
                if (bfCard) return bfCard;
                // Check graveyard
                const gravCard = zones.graveyard?.find(c => c.id === cardId);
                if (gravCard) return gravCard;
                // Check exile
                const exileCard = zones.exile?.find(c => c.id === cardId);
                if (exileCard) return exileCard;
                // Check command zone
                const cmdCard = zones.command?.find(c => c.id === cardId);
                if (cmdCard) return cmdCard;
            }
            return null;
        }

        // Find which zone a card is currently in
        function findCardZone(cardId) {
            if (!gameState || !gameState.zones_data) return null;
            for (const seat of Object.keys(gameState.zones_data)) {
                const zones = gameState.zones_data[seat];
                if (zones.hand?.find(c => c.id === cardId)) return 'hand';
                if (zones.battlefield?.find(c => c.id === cardId)) return 'battlefield';
                if (zones.graveyard?.find(c => c.id === cardId)) return 'graveyard';
                if (zones.exile?.find(c => c.id === cardId)) return 'exile';
                if (zones.command?.find(c => c.id === cardId)) return 'command';
            }
            return null;
        }

        function renderBattlefieldCards(cards, isMe, seat) {
            if (!cards.length) return '';

            // Get stack data for this seat
            const seatData = getSeatStackData(seat);

            // Group cards: stacked cards together, single cards separate
            const rendered = new Set();
            const result = [];

            cards.forEach(card => {
                if (rendered.has(card.id)) return;

                const stackId = seatData.cardToStack.get(card.id);
                const stack = stackId ? seatData.cardStacks.get(stackId) : null;

                if (stack) {
                    // This card is part of a stack
                    // Only render stack once (when we encounter the first card of it)
                    if (stack.cards.some(cid => rendered.has(cid))) return;

                    // Get all cards in this stack that are in this row
                    const stackCards = stack.cards
                        .map(cid => cards.find(c => c.id === cid))
                        .filter(c => c != null);

                    if (stackCards.length > 0) {
                        result.push(renderCardStack(stackCards, stack, isMe, stackId, seat));
                        stackCards.forEach(c => rendered.add(c.id));
                    }
                } else {
                    // Single card, not in a stack
                    result.push(renderSingleBattlefieldCard(card, isMe));
                    rendered.add(card.id);
                }
            });

            return result.join('');
        }

        function renderSingleBattlefieldCard(card, isMe) {
            let countersHtml = '';
            if (card.counters && Object.keys(card.counters).length > 0) {
                const text = Object.entries(card.counters).filter(([k,v]) => v > 0).map(([k,v]) => `${k}:${v}`).join(' ');
                if (text) countersHtml = `<div class="counters">${text}</div>`;
            }
            const isSelected = selectedCards.has(card.id);
            const isArrowSource = arrowSourceCards.has(card.id);
            const hasArrowFrom = arrows.some(a => a.sourceCardId === card.id);
            const hasArrowTo = arrows.some(a => a.targetType === 'card' && a.targetId === card.id);
            const hasArrow = hasArrowFrom || hasArrowTo;
            const draggable = isMe ? 'draggable="true"' : '';
            const dragStart = isMe ? `ondragstart="handleDragStart(event, '${card.id}', 'battlefield')"` : '';
            const dragEnd = isMe ? `ondragend="handleBattlefieldDragEnd(event)"` : '';
            const dropHandlers = isMe ? `ondragover="handleBattlefieldCardDragOver(event, '${card.id}')" ondragleave="handleBattlefieldCardDragLeave(event)" ondrop="handleBattlefieldCardDrop(event, '${card.id}')"` : '';
            const contextMenu = `oncontextmenu="showBattlefieldContextMenu(event, ${JSON.stringify(card).replace(/"/g, '&quot;')}, ${isMe}); return false;"`;

            return `
                <div class="card ${card.is_tapped ? 'tapped' : ''} ${card.is_commander ? 'commander' : ''} ${isSelected ? 'selected' : ''} ${isArrowSource ? 'arrow-source' : ''} ${hasArrow ? 'has-arrow' : ''}"
                     data-id="${card.id}" ${draggable}
                     ${dragStart} ${dragEnd} ${dropHandlers}
                     onclick="handleBattlefieldCardClick(event, '${card.id}', ${isMe})"
                     ondblclick="${isMe ? `event.stopPropagation(); toggleTap('${card.id}')` : ''}"
                     ${contextMenu}>
                    <img src="${card.image_small}" alt="${card.name}" draggable="false">
                    ${countersHtml}
                </div>
            `;
        }

        function renderCardStack(stackCards, stack, isMe, stackId, seat) {
            const topCard = stackCards[stackCards.length - 1];

            // Render stack container with all cards
            let cardsHtml = stackCards.map((card, index) => {
                const isTop = index === stackCards.length - 1;
                let countersHtml = '';
                if (card.counters && Object.keys(card.counters).length > 0) {
                    const text = Object.entries(card.counters).filter(([k,v]) => v > 0).map(([k,v]) => `${k}:${v}`).join(' ');
                    if (text) countersHtml = `<div class="counters">${text}</div>`;
                }
                const isSelected = selectedCards.has(card.id);
                const isArrowSource = arrowSourceCards.has(card.id);
                const hasArrowFrom = arrows.some(a => a.sourceCardId === card.id);
                const hasArrowTo = arrows.some(a => a.targetType === 'card' && a.targetId === card.id);
                const hasArrow = hasArrowFrom || hasArrowTo;
                const draggable = isMe ? 'draggable="true"' : '';
                const dragStart = isMe ? `ondragstart="handleStackCardDragStart(event, '${card.id}', 'battlefield')"` : '';
                const dragEnd = isMe ? `ondragend="handleBattlefieldDragEnd(event)"` : '';
                const dropHandlers = isMe && isTop ? `ondragover="handleBattlefieldCardDragOver(event, '${card.id}')" ondragleave="handleBattlefieldCardDragLeave(event)" ondrop="handleBattlefieldCardDrop(event, '${card.id}')"` : '';
                const contextMenu = `oncontextmenu="showStackCardContextMenu(event, ${JSON.stringify(card).replace(/"/g, '&quot;')}, ${isMe}, ${stackId}); return false;"`;
                const stackedClass = isTop ? 'stack-top' : 'stacked';

                return `
                    <div class="card ${stackedClass} ${card.is_tapped ? 'tapped' : ''} ${card.is_commander ? 'commander' : ''} ${isSelected ? 'selected' : ''} ${isArrowSource ? 'arrow-source' : ''} ${hasArrow ? 'has-arrow' : ''}"
                         data-id="${card.id}" ${draggable}
                         ${dragStart} ${dragEnd} ${dropHandlers}
                         onclick="handleStackCardClick(event, '${card.id}', ${isMe}, ${stackId})"
                         ondblclick="${isMe ? `event.stopPropagation(); toggleTap('${card.id}')` : ''}"
                         ${contextMenu}>
                        <img src="${card.image_small}" alt="${card.name}" draggable="false">
                        ${countersHtml}
                    </div>
                `;
            }).join('');

            // Check if any card in stack is tapped
            const hasTapped = stackCards.some(c => c.is_tapped);

            return `
                <div class="card-stack ${hasTapped ? 'has-tapped' : ''}" data-stack-id="${stackId}">
                    ${cardsHtml}
                </div>
            `;
        }

        function handleStackCardDragStart(e, cardId, zone) {
            // When dragging from a stack, unstack the card first
            unstackCard(cardId);
            handleDragStart(e, cardId, zone);
        }

        function handleStackCardClick(e, cardId, isMe, stackId) {
            e.stopPropagation();
            // Normal click behavior - show card or select
            handleBattlefieldCardClick(e, cardId, isMe);
        }

        function showStackCardContextMenu(e, card, isMe, stackId) {
            e.preventDefault();
            e.stopPropagation();

            if (isMe) {
                const items = [
                    { label: 'Ver carta', action: `showCardModal('${card.id}', '${card.image_normal}', '${card.name.replace(/'/g, "\\'")}', 'battlefield', true); hideContextMenu();` },
                    { divider: true },
                    { label: card.is_tapped ? 'Desvirar' : 'Virar', action: `toggleTap('${card.id}'); hideContextMenu();` },
                    { divider: true },
                    { label: 'Remover da pilha', action: `unstackCard('${card.id}'); renderPlayersGrid(true); hideContextMenu();` },
                    { label: 'Desempilhar todas', action: `unstackAll(${stackId}); hideContextMenu();` },
                    { divider: true },
                    { label: 'Mover para mao', action: `sendAction('move_card', {object_id: '${card.id}', zone: 'hand'}); unstackCard('${card.id}'); hideContextMenu();` },
                    { label: 'Mover para cemiterio', action: `sendAction('move_card', {object_id: '${card.id}', zone: 'graveyard'}); unstackCard('${card.id}'); hideContextMenu();` },
                    { label: 'Exilar', action: `sendAction('move_card', {object_id: '${card.id}', zone: 'exile'}); unstackCard('${card.id}'); hideContextMenu();` },
                ];
                showContextMenu(e, items);
            } else {
                showBattlefieldContextMenu(e, card, isMe);
            }
        }

        // Track last state for my zones to avoid unnecessary re-renders
        let lastGraveyardTopId = null;
        let lastExileTopId = null;
        let lastCommandIds = '';

        function renderMyZones() {
            const zones = gameState.zones_data[mySeat];
            if (!zones) return;

            document.getElementById('libraryCount').textContent = zones.library_count;
            document.getElementById('graveyardCount').textContent = zones.graveyard.length;
            document.getElementById('exileCount').textContent = zones.exile.length;

            // Only update graveyard top if changed
            const gravTop = document.getElementById('graveyardTopCard');
            const currentGravTopId = zones.graveyard.length > 0 ? zones.graveyard[zones.graveyard.length - 1].id : null;
            if (currentGravTopId !== lastGraveyardTopId) {
                lastGraveyardTopId = currentGravTopId;
                if (zones.graveyard.length > 0) {
                    const top = zones.graveyard[zones.graveyard.length - 1];
                    gravTop.innerHTML = `<img src="${top.image_small}" alt="${top.name}">`;
                } else gravTop.innerHTML = '';
            }

            // Only update exile top if changed
            const exileTop = document.getElementById('exileTopCard');
            const currentExileTopId = zones.exile.length > 0 ? zones.exile[zones.exile.length - 1].id : null;
            if (currentExileTopId !== lastExileTopId) {
                lastExileTopId = currentExileTopId;
                if (zones.exile.length > 0) {
                    const top = zones.exile[zones.exile.length - 1];
                    exileTop.innerHTML = `<img src="${top.image_small}" alt="${top.name}">`;
                } else exileTop.innerHTML = '';
            }

            // Only update commander zone if changed
            const currentCommandIds = zones.command.map(c => c.id).join(',');
            if (currentCommandIds !== lastCommandIds) {
                lastCommandIds = currentCommandIds;
                document.getElementById('commanderCards').innerHTML = zones.command.map(c => `
                    <div class="card commander" data-id="${c.id}" draggable="true"
                         ondragstart="handleDragStart(event, '${c.id}', 'command')"
                         onclick="showCard('${c.id}', '${c.image_normal}', '${c.name}', 'command', true)"
                         ondblclick="event.stopPropagation(); moveCard('${c.id}', 'battlefield')"
                         oncontextmenu="showCommandContextMenu(event, '${c.id}'); return false;">
                        <img src="${c.image_small}" alt="${c.name}">
                    </div>
                `).join('');
            }
        }

        // Track last hand state to avoid unnecessary re-renders (blink fix)
        let lastHandHash = '';
        // Track last players grid state to avoid battlefield blink
        let lastPlayersGridHash = '';

        function renderMyHand(forceRender = false) {
            const zones = gameState.zones_data[mySeat];
            const handCards = zones ? zones.hand : [];
            document.getElementById('handCount').textContent = handCards.length;
            updateHandToggleCount(handCards.length);

            const container = document.getElementById('myHand');
            const newIds = handCards.map(c => c.id);
            const newIdsSet = new Set(newIds);

            // Sync handCardOrder with actual hand cards
            // Remove cards that are no longer in hand
            handCardOrder = handCardOrder.filter(id => newIdsSet.has(id));
            // Add new cards that aren't in order yet (to the end)
            newIds.forEach(id => {
                if (!handCardOrder.includes(id)) {
                    handCardOrder.push(id);
                }
            });

            // Sort cards according to handCardOrder
            const orderedCards = handCardOrder
                .map(id => handCards.find(c => c.id === id))
                .filter(c => c != null);

            const oldIds = lastHandHash ? lastHandHash.split(',') : [];
            const oldIdsSet = new Set(oldIds);

            // Check if only new cards were added (drawing) - order independent
            const addedIds = newIds.filter(id => !oldIdsSet.has(id));
            const removedIds = oldIds.filter(id => !newIdsSet.has(id));

            // Case 1: Only cards added (drawing) - append to container
            if (!forceRender && oldIds.length > 0 && addedIds.length > 0 && removedIds.length === 0) {
                addedIds.forEach(cardId => {
                    const card = handCards.find(c => c.id === cardId);
                    if (!card) return;
                    const cardEl = createHandCardElement(card);
                    container.appendChild(cardEl);
                });
                lastHandHash = handCardOrder.join(',');
                return;
            }

            // Case 2: Only cards removed (playing/discarding)
            if (!forceRender && oldIds.length > 0 && removedIds.length > 0 && addedIds.length === 0) {
                removedIds.forEach(id => {
                    const cardEl = container.querySelector(`.card[data-id="${id}"]`);
                    if (cardEl) cardEl.remove();
                });
                lastHandHash = handCardOrder.join(',');
                return;
            }

            // Case 3: No change (check using ordered hash)
            const handHash = handCardOrder.join(',');
            if (!forceRender && handHash === lastHandHash) {
                return;
            }

            // Case 4: Full re-render (complex changes, first render, reorder, etc.)
            lastHandHash = handHash;

            if (!orderedCards.length) {
                container.innerHTML = '<div style="color:#555;font-size:0.75rem;">Mao vazia</div>';
                return;
            }

            container.innerHTML = orderedCards.map(card => {
                const escapedName = (card.name || '').replace(/&/g, '&amp;').replace(/'/g, '&#39;').replace(/"/g, '&quot;');
                const escapedImage = (card.image_normal || '').replace(/&/g, '&amp;').replace(/'/g, '&#39;').replace(/"/g, '&quot;');
                return `
                    <div class="card" data-id="${card.id}" draggable="true"
                         ondragstart="handleDragStart(event, '${card.id}', 'hand')"
                         ondragend="handleHandCardDragEnd(event)"
                         onclick="showCardById('${card.id}', 'hand', true)"
                         oncontextmenu="showHandContextMenuById(event, '${card.id}'); return false;">
                        <img src="${escapedImage}" alt="${escapedName}" draggable="false">
                    </div>
                `;
            }).join('');
        }

        function createHandCardElement(card) {
            const escapedName = (card.name || '').replace(/&/g, '&amp;').replace(/'/g, '&#39;').replace(/"/g, '&quot;');
            const escapedImage = (card.image_normal || '').replace(/&/g, '&amp;').replace(/'/g, '&#39;').replace(/"/g, '&quot;');
            const cardEl = document.createElement('div');
            cardEl.className = 'card';
            cardEl.dataset.id = card.id;
            cardEl.draggable = true;
            cardEl.setAttribute('ondragstart', `handleDragStart(event, '${card.id}', 'hand')`);
            cardEl.setAttribute('ondragend', `handleHandCardDragEnd(event)`);
            cardEl.setAttribute('onclick', `showCardById('${card.id}', 'hand', true)`);
            cardEl.setAttribute('oncontextmenu', `showHandContextMenuById(event, '${card.id}'); return false;`);
            cardEl.innerHTML = `<img src="${escapedImage}" alt="${escapedName}" draggable="false">`;
            return cardEl;
        }

        function renderActionLog() {
            const container = document.getElementById('actionLog');
            if (!gameState.recent_actions) return;
            container.innerHTML = gameState.recent_actions.map(action => `
                <div class="log-entry"><span class="turn-num">[T${action.turn_number}]</span> ${action.display_text}</div>
            `).join('');
        }

        // ===== ARROWS =====
        function startArrowFromCard(cardId) {
            // If already in arrow mode, add this card to sources
            if (arrowMode) {
                arrowSourceCards.add(cardId);
            } else {
                arrowMode = true;
                arrowSourceCards.clear();
                arrowSourceCards.add(cardId);
                arrowPreviewPos = { ...lastMousePos }; // Use current mouse position
                // Add mousemove listener for preview
                document.addEventListener('mousemove', handleArrowMouseMove);
            }
            document.body.style.cursor = 'crosshair';
            renderGame();
            renderArrows(); // Immediately render preview at current position
        }

        function startArrowFromSelected() {
            if (selectedCards.size === 0) return;
            arrowMode = true;
            arrowSourceCards = new Set(selectedCards);
            arrowPreviewPos = { ...lastMousePos }; // Use current mouse position
            document.addEventListener('mousemove', handleArrowMouseMove);
            document.body.style.cursor = 'crosshair';
            renderGame();
            renderArrows(); // Immediately render preview at current position
        }

        function handleArrowMouseMove(e) {
            arrowPreviewPos = { x: e.clientX, y: e.clientY };
            renderArrows();
        }

        function finalizeArrows(e) {
            if (!arrowMode || arrowSourceCards.size === 0) return;

            // Find which player area the click landed in
            let targetSeat = null;
            let targetXPercent = 50;
            let targetYPercent = 50;

            // Check each player area
            document.querySelectorAll('.player-area').forEach(area => {
                const rect = area.getBoundingClientRect();
                if (e.clientX >= rect.left && e.clientX <= rect.right &&
                    e.clientY >= rect.top && e.clientY <= rect.bottom) {
                    // Found the player area
                    const seatMatch = area.id.match(/playerArea-(\d+)/);
                    if (seatMatch) {
                        targetSeat = parseInt(seatMatch[1]);
                        // Calculate position as percentage within this player's area
                        targetXPercent = ((e.clientX - rect.left) / rect.width) * 100;
                        targetYPercent = ((e.clientY - rect.top) / rect.height) * 100;
                    }
                }
            });

            // If click wasn't in any player area, use playersGrid as reference
            if (targetSeat === null) {
                const grid = document.getElementById('playersGrid');
                if (grid) {
                    const rect = grid.getBoundingClientRect();
                    targetXPercent = ((e.clientX - rect.left) / rect.width) * 100;
                    targetYPercent = ((e.clientY - rect.top) / rect.height) * 100;
                }
            }

            // Create an arrow from each source card to the clicked position
            const newArrows = [];
            arrowSourceCards.forEach(cardId => {
                const arrow = {
                    sourceCardId: cardId,
                    targetType: 'position',
                    targetSeat: targetSeat, // Which player's area (null = grid)
                    targetXPercent: targetXPercent,
                    targetYPercent: targetYPercent,
                    creatorSeat: mySeat
                };
                arrows.push(arrow);
                newArrows.push(arrow);
            });

            // Send to server
            sendAction('create_arrows', { arrows: newArrows });

            cancelArrowMode();
            renderArrows();
        }

        function startArrowToPlayer(targetSeat) {
            if (arrowMode && arrowSourceCards.size > 0) {
                const newArrows = [];
                arrowSourceCards.forEach(cardId => {
                    const arrow = { sourceCardId: cardId, targetType: 'player', targetId: targetSeat, creatorSeat: mySeat };
                    arrows.push(arrow);
                    newArrows.push(arrow);
                });

                // Send to server
                sendAction('create_arrows', { arrows: newArrows });

                cancelArrowMode();
                renderArrows();
            }
        }

        function startArrowToCard(targetCardId) {
            if (arrowMode && arrowSourceCards.size > 0 && !arrowSourceCards.has(targetCardId)) {
                const newArrows = [];
                arrowSourceCards.forEach(cardId => {
                    const arrow = { sourceCardId: cardId, targetType: 'card', targetId: targetCardId, creatorSeat: mySeat };
                    arrows.push(arrow);
                    newArrows.push(arrow);
                });

                // Send to server
                sendAction('create_arrows', { arrows: newArrows });

                cancelArrowMode();
                renderArrows();
            }
        }

        function cancelArrowMode() {
            arrowMode = false;
            arrowSourceCards.clear();
            arrowPreviewPos = null;
            document.removeEventListener('mousemove', handleArrowMouseMove);
            document.body.style.cursor = '';
            document.querySelectorAll('.player-area').forEach(el => el.classList.remove('arrow-target'));
            document.querySelectorAll('.card').forEach(el => el.classList.remove('arrow-target-card'));
            renderGame();
        }

        function handlePlayerAreaClick(event, seat) {
            if (arrowMode && arrowSourceCards.size > 0) {
                arrowSourceCards.forEach(cardId => {
                    arrows.push({ sourceCardId: cardId, targetType: 'player', targetId: seat });
                });
                cancelArrowMode();
                renderArrows();
            }
        }

        function renderArrows() {
            requestAnimationFrame(() => {
                const svg = document.getElementById('arrowsSvg');
                const defs = svg.querySelector('defs');
                svg.innerHTML = '';
                svg.appendChild(defs);

                // Render existing arrows
                arrows.forEach((arrow, idx) => {
                    const sourceEl = document.querySelector(`[data-id="${arrow.sourceCardId}"]`);
                    if (!sourceEl) return;

                    const sourceRect = sourceEl.getBoundingClientRect();
                    const x1 = sourceRect.left + sourceRect.width / 2;
                    const y1 = sourceRect.top + sourceRect.height / 2;
                    let x2, y2;

                    if (arrow.targetType === 'position') {
                        // Convert percentage to pixels based on target player area or grid
                        if (arrow.targetSeat !== null && arrow.targetSeat !== undefined) {
                            const targetArea = document.getElementById(`playerArea-${arrow.targetSeat}`);
                            if (targetArea) {
                                const rect = targetArea.getBoundingClientRect();
                                x2 = rect.left + (arrow.targetXPercent / 100) * rect.width;
                                y2 = rect.top + (arrow.targetYPercent / 100) * rect.height;
                            } else {
                                return; // Target area not found
                            }
                        } else {
                            // Fallback to playersGrid
                            const grid = document.getElementById('playersGrid');
                            if (grid) {
                                const rect = grid.getBoundingClientRect();
                                x2 = rect.left + (arrow.targetXPercent / 100) * rect.width;
                                y2 = rect.top + (arrow.targetYPercent / 100) * rect.height;
                            } else {
                                return;
                            }
                        }
                    } else if (arrow.targetType === 'player') {
                        const targetEl = document.getElementById(`playerArea-${arrow.targetId}`);
                        if (!targetEl) return;
                        const targetRect = targetEl.getBoundingClientRect();
                        x2 = targetRect.left + targetRect.width / 2;
                        y2 = targetRect.top + 30;
                    } else if (arrow.targetType === 'card') {
                        const targetEl = document.querySelector(`[data-id="${arrow.targetId}"]`);
                        if (!targetEl) return;
                        const targetRect = targetEl.getBoundingClientRect();
                        x2 = targetRect.left + targetRect.width / 2;
                        y2 = targetRect.top + targetRect.height / 2;
                    } else {
                        // Legacy support
                        const targetEl = document.getElementById(`playerArea-${arrow.targetSeat}`);
                        if (!targetEl) return;
                        const targetRect = targetEl.getBoundingClientRect();
                        x2 = targetRect.left + targetRect.width / 2;
                        y2 = targetRect.top + 30;
                    }

                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', x1);
                    line.setAttribute('y1', y1);
                    line.setAttribute('x2', x2);
                    line.setAttribute('y2', y2);
                    line.setAttribute('class', 'arrow-line');
                    line.setAttribute('data-arrow-idx', idx);
                    line.style.pointerEvents = 'stroke';
                    line.onclick = (e) => {
                        e.stopPropagation();
                        removeArrow(idx);
                    };
                    svg.appendChild(line);
                });

                // Render preview arrows (during arrow mode)
                if (arrowMode && arrowPreviewPos && arrowSourceCards.size > 0) {
                    arrowSourceCards.forEach(cardId => {
                        const sourceEl = document.querySelector(`[data-id="${cardId}"]`);
                        if (!sourceEl) return;

                        const sourceRect = sourceEl.getBoundingClientRect();
                        const x1 = sourceRect.left + sourceRect.width / 2;
                        const y1 = sourceRect.top + sourceRect.height / 2;

                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        line.setAttribute('x1', x1);
                        line.setAttribute('y1', y1);
                        line.setAttribute('x2', arrowPreviewPos.x);
                        line.setAttribute('y2', arrowPreviewPos.y);
                        line.setAttribute('class', 'arrow-line');
                        line.style.opacity = '0.6';
                        line.style.strokeDasharray = '5,5';
                        svg.appendChild(line);
                    });
                }
            });
        }

        function removeArrow(idx) {
            const removedArrow = arrows[idx];
            arrows.splice(idx, 1);
            // Send to server
            if (removedArrow) {
                sendAction('remove_arrow', { arrow: removedArrow });
            }
            renderGame();
        }

        function removeArrowsFromCard(cardId) {
            const removedArrows = arrows.filter(a => a.sourceCardId === cardId);
            arrows = arrows.filter(a => a.sourceCardId !== cardId);
            // Send to server
            if (removedArrows.length > 0) {
                sendAction('remove_arrows', { sourceCardId: cardId });
            }
            renderGame();
        }

        function clearAllArrows() {
            arrows = [];
            // Send to server
            sendAction('clear_arrows', {});
            renderGame();
        }

        // Receive arrows from server (called when other players create/remove arrows)
        function handleArrowsUpdate(data) {
            if (data.action === 'set_arrows') {
                // Full sync
                arrows = data.arrows || [];
            } else if (data.action === 'add_arrows') {
                // Add new arrows from another player
                const newArrows = data.arrows || [];
                newArrows.forEach(arrow => {
                    // Avoid duplicates
                    const exists = arrows.some(a =>
                        a.sourceCardId === arrow.sourceCardId &&
                        a.targetType === arrow.targetType &&
                        a.targetId === arrow.targetId &&
                        a.targetXPercent === arrow.targetXPercent
                    );
                    if (!exists) {
                        arrows.push(arrow);
                    }
                });
            } else if (data.action === 'remove_arrow') {
                const arrow = data.arrow;
                arrows = arrows.filter(a => !(
                    a.sourceCardId === arrow.sourceCardId &&
                    a.targetType === arrow.targetType &&
                    a.targetId === arrow.targetId
                ));
            } else if (data.action === 'remove_from_card') {
                arrows = arrows.filter(a => a.sourceCardId !== data.sourceCardId);
            } else if (data.action === 'clear_all') {
                arrows = [];
            }
            renderArrows();
        }

        // ===== GENERIC COUNTERS =====
        function openCounterModal(seat, color) {
            counterModalData = { seat, color };
            const value = playerCounters[seat]?.[color] || 0;
            document.getElementById('counterValue').textContent = value;
            document.getElementById('counterModalTitle').textContent = `Marcador ${color.charAt(0).toUpperCase() + color.slice(1)}`;
            document.getElementById('counterModal').classList.add('show');
        }

        function closeCounterModal() {
            document.getElementById('counterModal').classList.remove('show');
        }

        function adjustCounter(delta) {
            const { seat, color } = counterModalData;
            if (!playerCounters[seat]) playerCounters[seat] = { red: 0, blue: 0, green: 0, yellow: 0, purple: 0 };
            playerCounters[seat][color] = Math.max(0, (playerCounters[seat][color] || 0) + delta);
            document.getElementById('counterValue').textContent = playerCounters[seat][color];
            renderGame();
        }

        // ===== DRAG AND DROP =====
        function handleDragStart(e, cardId, zone) {
            draggedCard = cardId;
            draggedCardData = { id: cardId, zone };
            e.dataTransfer.setData('text/plain', cardId);
            e.dataTransfer.effectAllowed = 'move';
            e.target.classList.add('dragging');

            // If dragging from hand, mark container as active
            if (zone === 'hand') {
                const handContainer = document.getElementById('myHand');
                if (handContainer) handContainer.classList.add('dragging-active');
            }

            // If dragging a selected card from battlefield, include all selected cards
            if (zone === 'battlefield' && selectedCards.has(cardId) && selectedCards.size > 1) {
                draggedCards = new Set(selectedCards);
                // Add visual feedback to all dragged cards
                draggedCards.forEach(id => {
                    const el = document.querySelector(`.card[data-id="${id}"]`);
                    if (el) el.classList.add('dragging');
                });
            } else {
                draggedCards.clear();
                draggedCards.add(cardId);
            }
        }

        function handleZoneDragStart(e, cardId, zone) {
            // Close the zone viewer modal when starting to drag
            closeZoneViewer();
            // Then handle normal drag start
            draggedCard = cardId;
            draggedCardData = { id: cardId, zone };
            e.dataTransfer.setData('text/plain', cardId);
            e.dataTransfer.effectAllowed = 'move';
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.currentTarget.classList.add('drag-over');
        }

        function handleDragLeave(e) {
            e.currentTarget.classList.remove('drag-over');
        }

        function handlePlayerDragOver(e, targetSeat) {
            e.preventDefault();
            e.currentTarget.classList.add('drag-over-player');
        }

        function handlePlayerDragLeave(e) {
            e.currentTarget.classList.remove('drag-over-player');
        }

        function handlePlayerDrop(e, targetSeat) {
            e.preventDefault();
            e.currentTarget.classList.remove('drag-over-player');
            // Ignore drops on battlefield rows (handled by row-specific handler)
            if (e.target.closest('.battlefield-row')) return;
            // Ignore drops on the battlefield area itself (empty space between rows)
            if (e.target.closest('.player-battlefield')) {
                document.querySelectorAll('.dragging').forEach(el => el.classList.remove('dragging'));
                draggedCard = null;
                draggedCardData = null;
                draggedCards.clear();
                return;
            }
            document.querySelectorAll('.dragging').forEach(el => el.classList.remove('dragging'));
            if (!draggedCard) return;

            // Move all dragged cards (single or multiple) to target player
            const cardsToMove = draggedCards.size > 0 ? [...draggedCards] : [draggedCard];

            cardsToMove.forEach(cardId => {
                sendAction('move_card', { object_id: cardId, zone: 'battlefield', target_seat: targetSeat });
            });

            // Clear selection after moving
            selectedCards.clear();
            updateCardSelectionVisual();

            draggedCard = null;
            draggedCardData = null;
            draggedCards.clear();
        }

        function handleRowDragOver(e) {
            e.preventDefault();
            e.stopPropagation();
            e.currentTarget.classList.add('drag-over');
        }

        function handleRowDragLeave(e) {
            e.currentTarget.classList.remove('drag-over');
        }

        function handleRowDrop(e, targetSeat, row) {
            e.preventDefault();
            e.stopPropagation();
            e.currentTarget.classList.remove('drag-over');
            document.querySelectorAll('.dragging').forEach(el => el.classList.remove('dragging'));
            document.querySelectorAll('.drag-over-player').forEach(el => el.classList.remove('drag-over-player'));
            if (!draggedCard) return;

            // Move all dragged cards (single or multiple)
            const cardsToMove = draggedCards.size > 0 ? [...draggedCards] : [draggedCard];

            cardsToMove.forEach(cardId => {
                // Optimistic visual update - move card element to new row immediately
                if (moveCardToRowVisual(cardId, targetSeat, row)) {
                    pendingRowChanges.set(cardId, row);
                }
                sendAction('move_card', { object_id: cardId, zone: 'battlefield', target_seat: targetSeat, row: row });
            });

            // Clear selection after moving
            selectedCards.clear();
            updateCardSelectionVisual();

            draggedCard = null;
            draggedCardData = null;
            draggedCards.clear();
        }

        function handleDropToMyZone(e, zone) {
            e.preventDefault();
            e.currentTarget.classList.remove('drag-over');
            document.querySelectorAll('.dragging').forEach(el => el.classList.remove('dragging'));
            if (!draggedCard) return;

            // Move all dragged cards (single or multiple)
            const cardsToMove = draggedCards.size > 0 ? [...draggedCards] : [draggedCard];

            cardsToMove.forEach(cardId => {
                sendAction('move_card', { object_id: cardId, zone });
            });

            // Clear selection after moving
            selectedCards.clear();
            updateCardSelectionVisual();

            draggedCard = null;
            draggedCardData = null;
            draggedCards.clear();
        }

        // Hand drop handlers
        function handleHandDragOver(e) {
            e.preventDefault();
            e.currentTarget.classList.add('drag-over');
        }

        function handleHandDragLeave(e) {
            e.currentTarget.classList.remove('drag-over');
        }

        function handleToggleBtnDragOver(e) {
            e.preventDefault();
            e.currentTarget.style.background = '#4ecdc4';
            e.currentTarget.style.transform = 'translateX(-50%) scale(1.1)';
            // Auto-open hand when hovering with dragged card
            if (!handOpen && draggedCard) {
                toggleHand();
            }
        }

        function handleToggleBtnDragLeave(e) {
            e.currentTarget.style.background = '';
            e.currentTarget.style.transform = '';
        }

        function handleDropToHand(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('drag-over');
            e.currentTarget.style.background = '';
            e.currentTarget.style.transform = '';
            document.querySelectorAll('.dragging').forEach(el => el.classList.remove('dragging'));
            if (!draggedCard) return;

            // If dropping from hand to hand (reordering)
            if (draggedCardData && draggedCardData.zone === 'hand') {
                // If we have a target from hovering over a card, perform reorder
                if (handDragTarget) {
                    reorderHandCard(draggedCard, handDragTarget.cardId, handDragTarget.position);
                }
                clearHandDragIndicators();
                draggedCard = null;
                draggedCardData = null;
                handDragTarget = null;
                draggedCards.clear();
                return;
            }

            // Move all dragged cards to hand (single or multiple)
            const cardsToMove = draggedCards.size > 0 ? [...draggedCards] : [draggedCard];

            cardsToMove.forEach(cardId => {
                sendAction('move_card', { object_id: cardId, zone: 'hand' });
            });

            // Clear selection after moving
            selectedCards.clear();
            updateCardSelectionVisual();

            draggedCard = null;
            draggedCardData = null;
            draggedCards.clear();
        }

        // ===== HAND CARD REORDERING (Event Delegation) =====
        // Setup event delegation on the hand cards container
        document.addEventListener('DOMContentLoaded', () => {
            const handCardsContainer = document.getElementById('myHand');
            if (handCardsContainer) {
                handCardsContainer.addEventListener('dragover', handleMyHandDragOver);
                handCardsContainer.addEventListener('drop', handleMyHandDrop);
                handCardsContainer.addEventListener('dragleave', handleMyHandDragLeave);
            }
        });

        function handleMyHandDragOver(e) {
            e.preventDefault();

            if (!draggedCard) return;

            // Find the card element under the cursor
            const cardEl = e.target.closest('.card');

            if (cardEl && draggedCardData && draggedCardData.zone === 'hand') {
                const cardId = cardEl.dataset.id;
                if (draggedCard === cardId) return;

                const rect = cardEl.getBoundingClientRect();
                const midX = rect.left + rect.width / 2;
                const isLeft = e.clientX < midX;

                // Clear previous indicators
                clearHandDragIndicators();

                // Show indicator on this card
                cardEl.classList.add(isLeft ? 'drag-over-left' : 'drag-over-right');
                handDragTarget = { cardId, position: isLeft ? 'before' : 'after' };
            }
        }

        function handleMyHandDragLeave(e) {
            // Only clear if leaving the container entirely
            if (!e.currentTarget.contains(e.relatedTarget)) {
                clearHandDragIndicators();
            }
        }

        function handleMyHandDrop(e) {
            e.preventDefault();
            e.stopPropagation();

            if (!draggedCard) return;

            // If dropping from hand (reordering)
            if (draggedCardData && draggedCardData.zone === 'hand') {
                if (handDragTarget) {
                    reorderHandCard(draggedCard, handDragTarget.cardId, handDragTarget.position);
                }
                clearHandDragIndicators();
                document.querySelectorAll('.dragging').forEach(el => el.classList.remove('dragging'));
                draggedCard = null;
                draggedCardData = null;
                handDragTarget = null;
                draggedCards.clear();
                return;
            }

            // If dropping from other zones (battlefield, exile, graveyard, etc.)
            const cardsToMove = draggedCards.size > 0 ? [...draggedCards] : [draggedCard];
            cardsToMove.forEach(cid => {
                sendAction('move_card', { object_id: cid, zone: 'hand' });
            });

            // Clear state
            selectedCards.clear();
            updateCardSelectionVisual();
            document.querySelectorAll('.dragging').forEach(el => el.classList.remove('dragging'));
            draggedCard = null;
            draggedCardData = null;
            draggedCards.clear();
        }

        // Keep old functions for backwards compatibility (in case they're called from HTML)
        function handleHandCardDragOver(e, cardId) {
            e.preventDefault();
        }

        function handleHandCardDragLeave(e) {
            // Handled by container
        }

        function handleHandCardDrop(e, cardId) {
            e.preventDefault();
            e.stopPropagation();
            // Let container handle it
            handleMyHandDrop(e);
        }

        function clearHandDragIndicators() {
            document.querySelectorAll('.hand-cards .card').forEach(el => {
                el.classList.remove('drag-over-left', 'drag-over-right');
            });

            // Also remove dragging-active class
            const handContainer = document.getElementById('myHand');
            if (handContainer) handContainer.classList.remove('dragging-active');
        }

        function reorderHandCard(movedCardId, targetCardId, position) {
            // Get current hand order
            const zones = gameState.zones_data[mySeat];
            const handCards = zones ? zones.hand : [];

            // Initialize handCardOrder if needed
            if (handCardOrder.length === 0 || !handCards.every(c => handCardOrder.includes(c.id))) {
                handCardOrder = handCards.map(c => c.id);
            }

            // Remove moved card from current position
            const movedIndex = handCardOrder.indexOf(movedCardId);
            if (movedIndex === -1) return;
            handCardOrder.splice(movedIndex, 1);

            // Find target position and insert
            let targetIndex = handCardOrder.indexOf(targetCardId);
            if (targetIndex === -1) return;

            if (position === 'after') {
                targetIndex++;
            }

            handCardOrder.splice(targetIndex, 0, movedCardId);

            // Direct DOM manipulation instead of full re-render
            const container = document.getElementById('myHand');
            const movedEl = container.querySelector(`.card[data-id="${movedCardId}"]`);
            const targetEl = container.querySelector(`.card[data-id="${targetCardId}"]`);

            if (movedEl && targetEl) {
                if (position === 'before') {
                    container.insertBefore(movedEl, targetEl);
                } else {
                    container.insertBefore(movedEl, targetEl.nextSibling);
                }
                // Update hash to prevent re-render on next game state update
                lastHandHash = handCardOrder.join(',');
            } else {
                // Fallback to full re-render if elements not found
                renderMyHand(true);
            }
        }

        function handleHandCardDragEnd(e) {
            clearHandDragIndicators();
            e.currentTarget.classList.remove('dragging');
            draggedCard = null;
            draggedCardData = null;
            handDragTarget = null;
            draggedCards.clear();

            // Remove dragging-active from hand container
            const handContainer = document.getElementById('myHand');
            if (handContainer) handContainer.classList.remove('dragging-active');
        }

        function handleBattlefieldDragEnd(e) {
            document.querySelectorAll('.dragging').forEach(el => el.classList.remove('dragging'));
            document.querySelectorAll('.stack-drop-target').forEach(el => el.classList.remove('stack-drop-target'));
            draggedCard = null;
            draggedCardData = null;
            draggedCards.clear();
        }

        // ===== CARD STACKING =====
        function stackCards(bottomCardId, topCardId) {
            updateLocalStackRefs();

            // Check if bottom card is already in a stack
            const existingStackId = cardToStack.get(bottomCardId);

            if (existingStackId) {
                // Add to existing stack
                const stack = cardStacks.get(existingStackId);
                if (stack && !stack.cards.includes(topCardId)) {
                    // Remove topCard from any existing stack
                    unstackCard(topCardId);
                    stack.cards.push(topCardId);
                    stack.topCardId = topCardId;
                    cardToStack.set(topCardId, existingStackId);
                }
            } else {
                // Create new stack
                // Remove topCard from any existing stack first
                unstackCard(topCardId);
                const data = getMyStackData();
                const stackId = data.nextStackId++;
                cardStacks.set(stackId, {
                    cards: [bottomCardId, topCardId],
                    topCardId: topCardId
                });
                cardToStack.set(bottomCardId, stackId);
                cardToStack.set(topCardId, stackId);
            }

            // Sync stacks to other players
            syncStacksToServer();

            // Re-render to show stack
            renderPlayersGrid(true);
        }

        function unstackCard(cardId) {
            updateLocalStackRefs();
            const stackId = cardToStack.get(cardId);
            if (!stackId) return false;

            const stack = cardStacks.get(stackId);
            if (!stack) return false;

            // Remove card from stack
            const index = stack.cards.indexOf(cardId);
            if (index > -1) {
                stack.cards.splice(index, 1);
            }
            cardToStack.delete(cardId);

            // If stack has only 1 card left, dissolve it
            if (stack.cards.length <= 1) {
                if (stack.cards.length === 1) {
                    cardToStack.delete(stack.cards[0]);
                }
                cardStacks.delete(stackId);
            } else {
                // Update top card
                stack.topCardId = stack.cards[stack.cards.length - 1];
            }

            // Sync stacks to other players
            syncStacksToServer();

            return true;
        }

        function unstackAll(stackId) {
            updateLocalStackRefs();
            const stack = cardStacks.get(stackId);
            if (!stack) return;

            stack.cards.forEach(cardId => {
                cardToStack.delete(cardId);
            });
            cardStacks.delete(stackId);

            // Sync stacks to other players
            syncStacksToServer();

            renderPlayersGrid(true);
        }

        function getStackForCard(cardId, seat = null) {
            // If seat specified, use that seat's stacks
            const data = seat !== null ? getSeatStackData(seat) : getMyStackData();
            const stackId = data.cardToStack.get(cardId);
            if (!stackId) return null;
            return { stackId, stack: data.cardStacks.get(stackId) };
        }

        function getStackForCardAnySeat(cardId) {
            // Search all seats for this card's stack
            for (const seat in seatStacks) {
                const data = seatStacks[seat];
                const stackId = data.cardToStack.get(cardId);
                if (stackId) {
                    return { stackId, stack: data.cardStacks.get(stackId), seat: parseInt(seat) };
                }
            }
            return null;
        }

        function isCardTopOfStack(cardId) {
            const stackInfo = getStackForCardAnySeat(cardId);
            return stackInfo && stackInfo.stack.topCardId === cardId;
        }

        // Sync my stacks to server (broadcasts to other players)
        function syncStacksToServer() {
            if (!socket || socket.readyState !== WebSocket.OPEN) return;

            updateLocalStackRefs();
            // Convert Map to array for JSON serialization
            const stacksArray = [];
            cardStacks.forEach((stack, stackId) => {
                stacksArray.push({
                    id: stackId,
                    cards: stack.cards,
                    topCardId: stack.topCardId
                });
            });

            socket.send(JSON.stringify({
                action: 'sync_stacks',
                data: {
                    seat: mySeat,
                    stacks: stacksArray
                }
            }));
        }

        // Apply stack data received from another player
        function applyRemoteStacks(seat, stacksArray) {
            const data = getSeatStackData(seat);
            data.cardStacks.clear();
            data.cardToStack.clear();

            stacksArray.forEach(stackData => {
                data.cardStacks.set(stackData.id, {
                    cards: stackData.cards,
                    topCardId: stackData.topCardId
                });
                stackData.cards.forEach(cardId => {
                    data.cardToStack.set(cardId, stackData.id);
                });
                // Update nextStackId if needed
                if (stackData.id >= data.nextStackId) {
                    data.nextStackId = stackData.id + 1;
                }
            });

            // Re-render to show updated stacks
            renderPlayersGrid(true);
        }

        function isCardInStack(cardId) {
            return cardToStack.has(cardId);
        }

        // Clean up stacks when cards leave battlefield
        function cleanupStacksForMissingCards(battlefieldCardIds) {
            const battlefieldSet = new Set(battlefieldCardIds);
            cardToStack.forEach((stackId, cardId) => {
                if (!battlefieldSet.has(cardId)) {
                    unstackCard(cardId);
                }
            });
        }

        // Handle drop on a battlefield card (for stacking)
        function handleBattlefieldCardDrop(e, targetCardId) {
            e.preventDefault();
            e.stopPropagation();

            document.querySelectorAll('.stack-drop-target').forEach(el => el.classList.remove('stack-drop-target'));

            if (!draggedCard || draggedCard === targetCardId) return;

            // Only allow stacking from battlefield to battlefield
            if (!draggedCardData || draggedCardData.zone !== 'battlefield') return;

            // Stack the dragged card on top of the target
            stackCards(targetCardId, draggedCard);

            // Clear drag state
            document.querySelectorAll('.dragging').forEach(el => el.classList.remove('dragging'));
            selectedCards.clear();
            updateCardSelectionVisual();
            draggedCard = null;
            draggedCardData = null;
            draggedCards.clear();
        }

        function handleBattlefieldCardDragOver(e, cardId) {
            if (!draggedCard || draggedCard === cardId) return;
            if (!draggedCardData || draggedCardData.zone !== 'battlefield') return;

            e.preventDefault();
            e.stopPropagation();

            // Show drop indicator
            document.querySelectorAll('.stack-drop-target').forEach(el => el.classList.remove('stack-drop-target'));
            e.currentTarget.classList.add('stack-drop-target');
        }

        function handleBattlefieldCardDragLeave(e) {
            e.currentTarget.classList.remove('stack-drop-target');
        }

        // ===== CARD INTERACTIONS =====
        function handleCardClick(e, cardId, imageUrl, cardName, zone, isMe) {
            e.stopPropagation();
            if (arrowMode && arrowSourceCards.size > 0) {
                // Finalize arrows at click position
                finalizeArrows(e);
                return;
            }
            if (e.shiftKey && isMe) {
                if (selectedCards.has(cardId)) {
                    selectedCards.delete(cardId);
                } else {
                    selectedCards.add(cardId);
                }
                updateCardSelectionVisual(); // Surgical update, no blink
                return;
            }
            showCard(cardId, imageUrl, cardName, zone, isMe);
        }

        // Store selection before click for double-click handling
        let preClickSelection = new Set();
        let clickTimeout = null;

        // Track pending local actions to avoid unnecessary re-renders
        let pendingTaps = new Set(); // Card IDs that were tapped locally, waiting for server confirmation
        let localTapStates = {}; // Track expected tap states after local action
        let pendingRowChanges = new Map(); // Card ID -> new row, for cards being moved between rows
        let pendingRemovals = new Set(); // Card IDs being removed from battlefield, waiting for server confirmation
        let pendingAdditions = new Map(); // Card ID -> {card, row, seat}, for cards being added to battlefield

        // Surgical update for card selection - only toggles CSS classes without re-rendering
        function updateCardSelectionVisual() {
            document.querySelectorAll('.player-battlefield .card').forEach(cardEl => {
                const cardId = cardEl.dataset.id;
                if (selectedCards.has(cardId)) {
                    cardEl.classList.add('selected');
                } else {
                    cardEl.classList.remove('selected');
                }
            });
        }

        // Surgical update for card tap - only toggles CSS class without re-rendering
        function toggleCardTapVisual(cardId) {
            const cardEl = document.querySelector(`.player-battlefield .card[data-id="${cardId}"]`);
            if (cardEl) {
                cardEl.classList.toggle('tapped');
            }
        }

        // Surgical update for card row change - moves card DOM element to new row without re-rendering
        function moveCardToRowVisual(cardId, seat, newRow) {
            const cardEl = document.querySelector(`.player-battlefield .card[data-id="${cardId}"]`);
            if (!cardEl) return false;

            // Find the target row container
            const targetRow = document.querySelector(`.battlefield-row[data-row="${newRow}"][data-seat="${seat}"] .cards-container`);
            if (!targetRow) return false;

            // Move the card element to the new row
            targetRow.appendChild(cardEl);
            return true;
        }

        // Optimistic removal of card from battlefield - removes DOM element immediately
        function removeCardFromBattlefieldVisual(cardId) {
            const cardEl = document.querySelector(`.player-battlefield .card[data-id="${cardId}"]`);
            if (cardEl) {
                cardEl.remove();
                pendingRemovals.add(cardId);
                // Also remove from selection if selected
                selectedCards.delete(cardId);
                return true;
            }
            return false;
        }

        // Optimistic removal of card from hand
        // Note: Don't add to pendingRemovals - that's only for battlefield cards
        // Hand uses lastHandHash for tracking
        function removeCardFromHandVisual(cardId) {
            const cardEl = document.querySelector(`#myHand .card[data-id="${cardId}"]`);
            if (cardEl) {
                cardEl.remove();
                // Update hand hash to reflect removal (prevents re-render from trying to re-add)
                if (lastHandHash) {
                    const ids = lastHandHash.split(',').filter(id => id !== cardId);
                    lastHandHash = ids.join(',');
                }
                return true;
            }
            return false;
        }

        // Optimistic addition of card to battlefield - creates DOM element immediately
        function addCardToBattlefieldVisual(card, row, seat) {
            if (!card || !card.id) return false;

            // Find the target row container
            const targetRow = document.querySelector(`.battlefield-row[data-row="${row}"][data-seat="${seat}"] .cards-container`);
            if (!targetRow) return false;

            // Check if card already exists on battlefield (avoid duplicates)
            const existing = document.querySelector(`.player-battlefield .card[data-id="${card.id}"]`);
            if (existing) return false;

            const isMe = seat === mySeat;
            const escapedName = (card.name || '').replace(/&/g, '&amp;').replace(/'/g, '&#39;').replace(/"/g, '&quot;');
            const escapedImage = (card.image_small || card.image_normal || '').replace(/&/g, '&amp;').replace(/'/g, '&#39;').replace(/"/g, '&quot;');

            const cardEl = document.createElement('div');
            cardEl.className = `card ${card.is_commander ? 'commander' : ''}`;
            cardEl.dataset.id = card.id;
            if (isMe) {
                cardEl.draggable = true;
                cardEl.setAttribute('ondragstart', `handleDragStart(event, '${card.id}', 'battlefield')`);
                cardEl.setAttribute('ondragend', `handleBattlefieldDragEnd(event)`);
            }
            cardEl.setAttribute('onclick', `handleBattlefieldCardClick(event, '${card.id}', ${isMe})`);
            if (isMe) {
                cardEl.setAttribute('ondblclick', `event.stopPropagation(); toggleTap('${card.id}')`);
                cardEl.setAttribute('oncontextmenu', `showBattlefieldContextMenuById(event, '${card.id}', true); return false;`);
            } else {
                cardEl.setAttribute('oncontextmenu', `showBattlefieldContextMenuById(event, '${card.id}', false); return false;`);
            }
            cardEl.innerHTML = `<img src="${escapedImage}" alt="${escapedName}">`;

            targetRow.appendChild(cardEl);
            pendingAdditions.set(card.id, { card, row, seat });
            return true;
        }

        // Battlefield cards: single click only for selection, not opening modal
        function handleBattlefieldCardClick(e, cardId, isMe) {
            e.stopPropagation();
            // If in arrow mode, finalize arrows at click position
            if (arrowMode && arrowSourceCards.size > 0) {
                // If clicking on a card that's not a source, target that card
                if (!arrowSourceCards.has(cardId)) {
                    startArrowToCard(cardId);
                } else {
                    // Clicking on own source card - finalize at position
                    finalizeArrows(e);
                }
                return;
            }

            // Store current selection before modifying (for double-click)
            preClickSelection = new Set(selectedCards);

            // Shift+click for multi-select
            if (e.shiftKey && isMe) {
                if (selectedCards.has(cardId)) {
                    selectedCards.delete(cardId);
                } else {
                    selectedCards.add(cardId);
                }
                updateCardSelectionVisual(); // Surgical update, no blink
                return;
            }
            // Regular click: toggle selection (don't open modal)
            if (isMe) {
                // Use timeout to allow double-click to cancel single-click behavior
                if (clickTimeout) clearTimeout(clickTimeout);
                clickTimeout = setTimeout(() => {
                    if (selectedCards.has(cardId) && selectedCards.size === 1) {
                        selectedCards.delete(cardId);
                    } else if (!selectedCards.has(cardId)) {
                        // Clear other selections unless shift is held
                        selectedCards.clear();
                        selectedCards.add(cardId);
                    }
                    updateCardSelectionVisual(); // Surgical update, no blink
                }, 200); // 200ms delay to detect double-click
            }
            // For opponent cards, single click does nothing (use right-click to view)
        }

        function toggleTap(cardId) {
            // Cancel pending single-click
            if (clickTimeout) {
                clearTimeout(clickTimeout);
                clickTimeout = null;
            }

            // Use pre-click selection if it had multiple cards including this one
            if (preClickSelection.size > 1 && preClickSelection.has(cardId)) {
                preClickSelection.forEach(id => {
                    toggleCardTapVisual(id); // Optimistic update
                    pendingTaps.add(id);
                    sendAction('tap_card', { object_id: id });
                });
                selectedCards.clear();
                preClickSelection.clear();
                updateCardSelectionVisual();
            } else if (selectedCards.size > 0 && selectedCards.has(cardId)) {
                selectedCards.forEach(id => {
                    toggleCardTapVisual(id); // Optimistic update
                    pendingTaps.add(id);
                    sendAction('tap_card', { object_id: id });
                });
                selectedCards.clear();
                updateCardSelectionVisual();
            } else {
                toggleCardTapVisual(cardId); // Optimistic update
                pendingTaps.add(cardId);
                sendAction('tap_card', { object_id: cardId });
            }
        }

        // ===== MULTI-SELECT =====
        let selectionStartedInMyArea = false;

        document.addEventListener('mousedown', function(e) {
            if (e.button !== 0) return;
            // Allow starting selection from anywhere in my player area (including battlefield rows)
            if (e.target.closest('.context-menu, .card-modal, .modal-overlay, .autopay-modal, button, input, .sidebar, .phase-tracker, .player-header, .my-zones')) return;

            const playerArea = e.target.closest('.player-area.is-me');
            const battlefieldRow = e.target.closest('.battlefield-row');

            // Must be in my player area or one of my battlefield rows
            if (!playerArea && !battlefieldRow) return;
            if (battlefieldRow && !battlefieldRow.closest('.player-area.is-me')) return;

            // Don't start selection if clicking on a card (let card handlers deal with it)
            if (e.target.closest('.card')) return;

            isSelecting = true;
            selectionStartedInMyArea = true;
            selectionStart = { x: e.clientX, y: e.clientY };
            const box = document.getElementById('selectionBox');
            box.style.left = e.clientX + 'px';
            box.style.top = e.clientY + 'px';
            box.style.width = '0px';
            box.style.height = '0px';
            box.style.display = 'block';
        });

        document.addEventListener('mousemove', function(e) {
            if (!isSelecting) return;
            const box = document.getElementById('selectionBox');
            const x = Math.min(e.clientX, selectionStart.x);
            const y = Math.min(e.clientY, selectionStart.y);
            const w = Math.abs(e.clientX - selectionStart.x);
            const h = Math.abs(e.clientY - selectionStart.y);
            box.style.left = x + 'px';
            box.style.top = y + 'px';
            box.style.width = w + 'px';
            box.style.height = h + 'px';

            // Live preview: highlight cards that would be selected
            if (w > 5 || h > 5) {
                const boxRect = { left: x, top: y, right: x + w, bottom: y + h };
                const myArea = document.querySelector('.player-area.is-me');
                if (myArea) {
                    const cards = myArea.querySelectorAll('.battlefield-row .card[data-id]');
                    cards.forEach(card => {
                        const cardRect = card.getBoundingClientRect();
                        if (rectsIntersect(boxRect, cardRect)) {
                            card.classList.add('selection-preview');
                        } else {
                            card.classList.remove('selection-preview');
                        }
                    });
                }
            }
        });

        document.addEventListener('mouseup', function(e) {
            if (!isSelecting) return;
            isSelecting = false;
            selectionStartedInMyArea = false;
            const box = document.getElementById('selectionBox');
            const boxRect = box.getBoundingClientRect();
            box.style.display = 'none';

            // Remove all preview highlights
            document.querySelectorAll('.selection-preview').forEach(el => el.classList.remove('selection-preview'));

            // Minimum drag size to count as selection
            if (boxRect.width < 5 || boxRect.height < 5) return;

            const myArea = document.querySelector('.player-area.is-me');
            if (!myArea) return;

            // Only select cards from battlefield rows (not from hand)
            const cards = myArea.querySelectorAll('.battlefield-row .card[data-id]');
            const newSelection = new Set();

            cards.forEach(card => {
                const cardRect = card.getBoundingClientRect();
                if (rectsIntersect(boxRect, cardRect)) {
                    newSelection.add(card.dataset.id);
                }
            });

            // Only update if we selected at least one card
            if (newSelection.size > 0) {
                selectedCards = newSelection;
                updateCardSelectionVisual(); // Surgical update, no blink
            }
        });

        function rectsIntersect(r1, r2) {
            return !(r2.left > r1.right || r2.right < r1.left || r2.top > r1.bottom || r2.bottom < r1.top);
        }

        // ===== CONTEXT MENUS =====
        function showContextMenu(e, items, openUpward = false) {
            e.preventDefault();
            hideContextMenu();
            const menu = document.getElementById('contextMenu');
            const container = document.getElementById('contextMenuItems');
            container.innerHTML = items.map(item => {
                if (item.divider) return '<div class="context-menu-divider"></div>';
                return `<div class="context-menu-item" onclick="${item.action}">${item.label}</div>`;
            }).join('');

            // Calculate position
            const menuWidth = 160;
            let x = Math.min(e.clientX, window.innerWidth - menuWidth);

            // Show menu first to get its height
            menu.style.visibility = 'hidden';
            menu.classList.add('show');
            const menuHeight = menu.offsetHeight;

            let y;
            if (openUpward) {
                // Open upward (for hand cards at bottom)
                y = Math.max(10, e.clientY - menuHeight);
            } else {
                // Open downward (default)
                y = Math.min(e.clientY, window.innerHeight - menuHeight - 20);
            }

            menu.style.left = x + 'px';
            menu.style.top = y + 'px';
            menu.style.visibility = 'visible';
        }

        function hideContextMenu() {
            document.getElementById('contextMenu').classList.remove('show');
        }

        document.addEventListener('click', (e) => {
            if (!e.target.closest('.context-menu')) hideContextMenu();
            // Finalize arrows when clicking anywhere (not on cards/players/context menu/mulligan modal)
            if (arrowMode && arrowSourceCards.size > 0) {
                // Don't finalize if clicking on a card, context menu, modal, or mulligan modal
                if (!e.target.closest('.card') && !e.target.closest('.context-menu') && !e.target.closest('.modal') && !e.target.closest('.mulligan-modal')) {
                    finalizeArrows(e);
                }
            }
        });

        function showLibraryContextMenu(e) {
            const mulliganLabel = mulliganCount === 0
                ? 'Mulligan (compra 7, devolve 1)'
                : `Mulligan (compra 7, devolve ${mulliganCount + 1})`;

            showContextMenu(e, [
                { label: 'Comprar carta', action: "sendAction('draw_card'); hideContextMenu();" },
                { label: 'Comprar cartas...', action: "promptDrawCards(); hideContextMenu();" },
                { divider: true },
                { label: 'Ver topo (1)', action: "sendAction('look_top', {count: 1}); hideContextMenu();" },
                { label: 'Ver topo (3)', action: "sendAction('look_top', {count: 3}); hideContextMenu();" },
                { label: 'Videncia (Scry)...', action: "promptScry(); hideContextMenu();" },
                { divider: true },
                { label: 'Ver toda biblioteca', action: "sendAction('view_library'); hideContextMenu();" },
                { label: 'Embaralhar', action: "sendAction('shuffle_library'); animateShuffle(); hideContextMenu();" },
                { divider: true },
                { label: mulliganLabel, action: "performMulligan(); hideContextMenu();" },
            ]);
        }

        function showLibraryMenu() {
            showLibraryContextMenu({ clientX: window.innerWidth / 2, clientY: window.innerHeight / 2, preventDefault: () => {} });
        }

        function promptDrawCards() {
            const count = prompt('Quantas cartas deseja comprar?', '1');
            if (count !== null) {
                const num = parseInt(count);
                if (!isNaN(num) && num > 0) {
                    for (let i = 0; i < num; i++) {
                        sendAction('draw_card');
                    }
                }
            }
        }

        // ===== MULLIGAN SYSTEM =====
        let mulliganSelection = new Set(); // Cards selected to return in mulligan

        function performMulligan() {
            // Step 1: Return all hand cards to library
            const zones = gameState.zones_data[mySeat];
            if (zones && zones.hand) {
                zones.hand.forEach(card => {
                    sendAction('move_card', { object_id: card.id, zone: 'library' });
                });
            }

            // Step 2: Shuffle library
            sendAction('shuffle_library');
            animateShuffle();

            // Step 3: Draw 7 cards
            for (let i = 0; i < 7; i++) {
                sendAction('draw_card');
            }

            // Step 4: Increment mulligan count and set pending cards to return
            mulliganCount++;
            mulliganPending = mulliganCount;

            // Wait for cards to appear in hand, then show modal
            waitForHandCards(7, () => {
                showMulliganModal();
            });
        }

        function waitForHandCards(expectedCount, callback, maxAttempts = 20) {
            let attempts = 0;
            const check = () => {
                attempts++;
                const zones = gameState.zones_data[mySeat];
                const handCount = zones && zones.hand ? zones.hand.length : 0;

                if (handCount >= expectedCount) {
                    callback();
                } else if (attempts < maxAttempts) {
                    setTimeout(check, 300);
                } else {
                    // Fallback: show modal anyway after max attempts
                    callback();
                }
            };
            setTimeout(check, 500);
        }

        function showMulliganModal() {
            const modal = document.getElementById('mulliganModal');
            const container = document.getElementById('mulliganCards');
            const instructions = document.getElementById('mulliganInstructions');

            mulliganSelection.clear();

            instructions.textContent = `Selecione ${mulliganPending} carta${mulliganPending > 1 ? 's' : ''} para devolver ao topo da biblioteca`;

            // Get current hand
            const zones = gameState.zones_data[mySeat];
            const hand = zones && zones.hand ? zones.hand : [];

            container.innerHTML = hand.map(card => {
                const imageUrl = card.image_normal || '/static/images/card_back.png';
                return `<div class="mulligan-card" data-id="${card.id}" onclick="toggleMulliganCard('${card.id}', this)">
                            <img src="${imageUrl}" alt="${card.name || 'Card'}" draggable="false">
                        </div>`;
            }).join('');

            updateMulliganUI();
            modal.classList.add('show');
        }

        function toggleMulliganCard(cardId, element) {
            if (mulliganSelection.has(cardId)) {
                mulliganSelection.delete(cardId);
                element.classList.remove('selected');
            } else {
                // Only add if we haven't reached the limit
                if (mulliganSelection.size < mulliganPending) {
                    mulliganSelection.add(cardId);
                    element.classList.add('selected');
                }
            }
            updateMulliganUI();
        }

        function updateMulliganUI() {
            const countEl = document.getElementById('mulliganSelectionCount');
            const btn = document.getElementById('mulliganConfirmBtn');

            countEl.textContent = `${mulliganSelection.size} / ${mulliganPending} selecionadas`;

            // Enable confirm button only when exact count is selected
            btn.disabled = mulliganSelection.size !== mulliganPending;
        }

        function confirmMulligan() {
            if (mulliganSelection.size !== mulliganPending) return;

            // Move selected cards to top of library
            mulliganSelection.forEach(cardId => {
                sendAction('move_card', { object_id: cardId, zone: 'library', to_top: true });
            });

            // Close modal
            closeMulliganModal();
        }

        function closeMulliganModal() {
            mulliganSelection.clear();
            document.getElementById('mulliganModal').classList.remove('show');
        }

        // Mulligan modal cannot be closed by clicking outside - user MUST select cards

        function showHandZoneContextMenu(e) {
            // Don't show zone menu if clicking on a card - let card's own context menu handle it
            if (e.target.closest('.card')) return;

            const zones = gameState.zones_data[mySeat];
            const handCount = zones && zones.hand ? zones.hand.length : 0;

            if (handCount === 0) return;

            showContextMenu(e, [
                { label: `Descartar mao (${handCount})`, action: "discardHand(); hideContextMenu();" },
                { label: `Exilar mao (${handCount})`, action: "exileHand(); hideContextMenu();" },
            ], true);
        }

        function discardHand() {
            const zones = gameState.zones_data[mySeat];
            if (!zones || !zones.hand || zones.hand.length === 0) return;

            const cardIds = zones.hand.map(c => c.id);
            cardIds.forEach(cardId => {
                sendAction('move_card', { object_id: cardId, zone: 'graveyard' });
            });
        }

        function exileHand() {
            const zones = gameState.zones_data[mySeat];
            if (!zones || !zones.hand || zones.hand.length === 0) return;

            const cardIds = zones.hand.map(c => c.id);
            cardIds.forEach(cardId => {
                sendAction('move_card', { object_id: cardId, zone: 'exile' });
            });
        }

        // Helper to find card by ID from hand
        function getHandCardById(cardId) {
            const zones = gameState.zones_data[mySeat];
            return zones && zones.hand ? zones.hand.find(c => c.id === cardId) : null;
        }

        // Show card modal by ID (avoids escaping issues)
        function showCardById(cardId, zone, isMe) {
            const card = getHandCardById(cardId);
            if (card) {
                showCard(cardId, card.image_normal || '', card.name || '', zone, isMe);
            }
        }

        // Show hand context menu by ID (avoids escaping issues)
        function showHandContextMenuById(e, cardId) {
            const card = getHandCardById(cardId);
            if (card) {
                showHandContextMenu(e, card);
            }
        }

        function showHandContextMenu(e, card) {
            // Store card reference for autopay
            window._autopayCardRef = card;
            showContextMenu(e, [
                { label: 'Jogar no Campo', action: `moveCard('${card.id}', 'battlefield'); hideContextMenu();` },
                { label: 'Jogar (Auto-Pay) ', action: `openAutopayModal(window._autopayCardRef); hideContextMenu();` },
                { divider: true },
                { label: 'Descartar', action: `moveCard('${card.id}', 'graveyard'); hideContextMenu();` },
                { label: 'Exilar', action: `moveCard('${card.id}', 'exile'); hideContextMenu();` },
                { divider: true },
                { label: 'Revelar para todos', action: `sendAction('reveal_card', {object_id: '${card.id}'}); hideContextMenu();` },
                { divider: true },
                { label: 'Devolver ao topo', action: `sendAction('put_top', {object_id: '${card.id}'}); hideContextMenu();` },
                { label: 'Devolver ao fundo', action: `sendAction('put_bottom', {object_id: '${card.id}'}); hideContextMenu();` },
            ], true); // openUpward = true for hand cards
        }

        function showBattlefieldContextMenu(e, card, isMe = false) {
            const items = [];

            // Check if clicked card is in selection and there are multiple cards selected
            const isMultiSelect = selectedCards.has(card.id) && selectedCards.size > 1;
            const countLabel = isMultiSelect ? ` (${selectedCards.size})` : '';

            // Ver carta option (always single card)
            items.push({ label: 'Ver carta', action: `showCard('${card.id}', '${card.image_normal}', '${card.name}', 'battlefield', ${isMe}); hideContextMenu();` });

            if (isMe) {
                items.push({ divider: true });
                const tapLabel = card.is_tapped ? 'Desvirar' : 'Virar';
                if (isMultiSelect) {
                    items.push({ label: `${tapLabel}${countLabel}`, action: `tapSelected(); hideContextMenu();` });
                } else {
                    items.push({ label: tapLabel, action: `toggleTap('${card.id}'); hideContextMenu();` });
                }
                items.push({ divider: true });

                // Arrow actions - can create from selected cards
                if (isMultiSelect) {
                    items.push({ label: `Criar seta${countLabel}`, action: `startArrowFromSelected(); hideContextMenu();` });
                    // Check if any selected card has arrows
                    const selectedWithArrows = [...selectedCards].filter(id => arrows.some(a => a.sourceCardId === id));
                    if (selectedWithArrows.length > 0) {
                        items.push({ label: `Remover setas${countLabel}`, action: `removeArrowsFromSelected(); hideContextMenu();` });
                    }
                } else {
                    items.push({ label: 'Criar seta', action: `startArrowFromCard('${card.id}'); hideContextMenu();` });
                    const cardArrows = arrows.filter(a => a.sourceCardId === card.id);
                    if (cardArrows.length === 1) {
                        const idx = arrows.findIndex(a => a.sourceCardId === card.id);
                        items.push({ label: 'Remover seta', action: `removeArrow(${idx}); hideContextMenu();` });
                    } else if (cardArrows.length > 1) {
                        items.push({ label: `Remover todas setas (${cardArrows.length})`, action: `removeArrowsFromCard('${card.id}'); hideContextMenu();` });
                    }
                }

                items.push({ divider: true });

                // Move actions - use multi-select functions when applicable
                if (isMultiSelect) {
                    items.push({ label: `Enviar para Cemiterio${countLabel}`, action: `moveSelectedCards('graveyard'); hideContextMenu();` });
                    items.push({ label: `Exilar${countLabel}`, action: `moveSelectedCards('exile'); hideContextMenu();` });
                    items.push({ label: `Devolver a Mao${countLabel}`, action: `moveSelectedCards('hand'); hideContextMenu();` });
                } else {
                    items.push({ label: 'Enviar para Cemiterio', action: `moveCard('${card.id}', 'graveyard'); hideContextMenu();` });
                    items.push({ label: 'Exilar', action: `moveCard('${card.id}', 'exile'); hideContextMenu();` });
                    items.push({ label: 'Devolver a Mao', action: `moveCard('${card.id}', 'hand'); hideContextMenu();` });
                    if (card.is_commander) {
                        items.push({ label: 'Devolver a Zona de Comando', action: `moveCard('${card.id}', 'command'); hideContextMenu();` });
                    }
                }

                items.push({ divider: true });

                // Counter actions
                if (isMultiSelect) {
                    items.push({ label: `Adicionar +1/+1${countLabel}`, action: `addCounterToSelected(); hideContextMenu();` });
                    items.push({ label: `Remover +1/+1${countLabel}`, action: `removeCounterFromSelected(); hideContextMenu();` });
                } else {
                    items.push({ label: 'Adicionar +1/+1', action: `addCounter('${card.id}'); hideContextMenu();` });
                    items.push({ label: 'Remover +1/+1', action: `removeCounter('${card.id}'); hideContextMenu();` });
                }

                // Stack actions
                items.push({ divider: true });
                const stackInfo = getStackForCard(card.id);
                if (isMultiSelect && selectedCards.size >= 2) {
                    items.push({ label: `Empilhar selecionadas${countLabel}`, action: `stackSelectedCards(); hideContextMenu();` });
                }
                if (stackInfo) {
                    items.push({ label: 'Remover da pilha', action: `unstackCard('${card.id}'); renderPlayersGrid(true); hideContextMenu();` });
                    items.push({ label: 'Desempilhar todas', action: `unstackAll(${stackInfo.stackId}); hideContextMenu();` });
                }
            }
            showContextMenu(e, items);
        }

        function stackSelectedCards() {
            if (selectedCards.size < 2) return;
            const cardIds = [...selectedCards];
            // Stack all cards onto the first one
            const bottomCard = cardIds[0];
            for (let i = 1; i < cardIds.length; i++) {
                stackCards(bottomCard, cardIds[i]);
            }
            selectedCards.clear();
            updateCardSelectionVisual();
        }

        function showCommandContextMenu(e, cardId) {
            showContextMenu(e, [
                { label: 'Lancar Comandante', action: `moveCard('${cardId}', 'battlefield'); hideContextMenu();` },
                { label: 'Exilar', action: `moveCard('${cardId}', 'exile'); hideContextMenu();` },
            ]);
        }

        // Show battlefield context menu by ID (for optimistically added cards)
        function showBattlefieldContextMenuById(e, cardId, isMe) {
            const card = findCardById(cardId);
            if (card) {
                showBattlefieldContextMenu(e, card, isMe);
            }
        }

        function tapSelected() {
            selectedCards.forEach(id => sendAction('tap_card', { object_id: id }));
            selectedCards.clear();
            updateCardSelectionVisual(); // Surgical update for selection clear
        }

        // Multi-select helper functions
        function moveSelectedCards(zone) {
            // Use moveCard for each card to get optimistic updates
            selectedCards.forEach(id => {
                moveCard(id, zone);
            });
            selectedCards.clear();
            updateCardSelectionVisual();
        }

        function addCounterToSelected() {
            selectedCards.forEach(id => sendAction('add_counter', { object_id: id }));
        }

        function removeCounterFromSelected() {
            selectedCards.forEach(id => sendAction('remove_counter', { object_id: id }));
        }

        function removeArrowsFromSelected() {
            selectedCards.forEach(id => removeArrowsFromCard(id));
        }

        function promptScry() {
            const count = prompt('Quantas cartas? (1-10)', '3');
            const num = parseInt(count);
            if (num && num >= 1 && num <= 10) {
                sendAction('scry', { count: num });
            }
        }

        // ===== MODALS =====
        function showScryModal(cards, isScry = true) {
            scryCardsData = cards;
            document.getElementById('scryTitle').textContent = isScry ? 'Videncia - Escolha a ordem' : 'Cartas do topo';
            const container = document.getElementById('scryCards');
            container.innerHTML = cards.map(c => `
                <div class="card" data-id="${c.id}" draggable="true" ondragstart="handleScryDragStart(event, '${c.id}')">
                    <img src="${c.image_normal || c.image_small}" alt="${c.name}">
                </div>
            `).join('');
            document.getElementById('scryTopCards').innerHTML = '';
            document.getElementById('scryBottomCards').innerHTML = '';
            document.getElementById('scryModal').classList.add('show');
        }

        function handleScryDragStart(e, cardId) {
            e.dataTransfer.setData('text/plain', cardId);
        }

        function handleScryDrop(e, position) {
            e.preventDefault();
            e.currentTarget.classList.remove('drag-over');
            const cardId = e.dataTransfer.getData('text/plain');
            const card = scryCardsData.find(c => c.id === cardId);
            if (!card) return;
            document.querySelectorAll(`[data-id="${cardId}"]`).forEach(el => el.remove());
            const targetContainer = position === 'top' ? document.getElementById('scryTopCards') : document.getElementById('scryBottomCards');
            const div = document.createElement('div');
            div.className = 'card';
            div.dataset.id = cardId;
            div.draggable = true;
            div.ondragstart = (ev) => handleScryDragStart(ev, cardId);
            div.innerHTML = `<img src="${card.image_small || card.image_normal}" alt="${card.name}">`;
            targetContainer.appendChild(div);
        }

        function confirmScry() {
            const topCards = Array.from(document.querySelectorAll('#scryTopCards .card')).map(el => ({ id: el.dataset.id, position: 'top' }));
            const bottomCards = Array.from(document.querySelectorAll('#scryBottomCards .card')).map(el => ({ id: el.dataset.id, position: 'bottom' }));
            if (topCards.length + bottomCards.length > 0) {
                sendAction('reorder_scry', { order: [...topCards, ...bottomCards] });
            }
            closeScryModal();
        }

        function closeScryModal() {
            document.getElementById('scryModal').classList.remove('show');
            scryCardsData = [];
        }

        let currentZoneViewer = { zone: null, seat: null };
        let zoneViewerSelection = new Set(); // Selected cards in zone viewer

        function showZoneViewer(zoneName, seat = mySeat) {
            const zones = gameState.zones_data[seat];
            if (!zones) return;
            const cards = zones[zoneName] || [];
            const titles = { graveyard: 'Cemiterio', exile: 'Exilio', hand: 'Mao', command: 'Comando' };
            const player = gameState.players.find(p => p.seat_position === seat);
            const playerName = player ? player.nickname : '';
            document.getElementById('zoneViewerTitle').textContent = `${titles[zoneName] || zoneName} - ${playerName} (${cards.length})`;

            // Clear previous selection
            zoneViewerSelection.clear();
            updateZoneViewerActions();

            const isMyZone = seat === mySeat;
            document.getElementById('zoneViewerCards').innerHTML = cards.map(c => {
                const escapedName = (c.name || '').replace(/'/g, "\\'");
                const escapedImage = (c.image_normal || '').replace(/'/g, "\\'");
                const contextMenu = isMyZone ? `oncontextmenu="showZoneCardContextMenu(event, '${c.id}', '${zoneName}'); return false;"` : '';
                const draggable = isMyZone ? `draggable="true" ondragstart="handleZoneViewerDragStart(event, '${c.id}', '${zoneName}')" ondragend="handleZoneViewerDragEnd(event)"` : '';
                const clickHandler = isMyZone ? `onclick="handleZoneCardClick(event, '${c.id}', '${escapedImage}', '${escapedName}', '${zoneName}')"` : `onclick="showCard('${c.id}', '${escapedImage}', '${escapedName}', '${zoneName}', false)"`;
                return `
                    <div class="card" data-id="${c.id}"
                         ${clickHandler}
                         ${contextMenu} ${draggable}>
                        <img src="${c.image_normal}" alt="${c.name}">
                    </div>
                `;
            }).join('');

            // Show "Exile All" button only for my own graveyard
            const exileBtn = document.getElementById('exileAllGraveyardBtn');
            if (zoneName === 'graveyard' && seat === mySeat && cards.length > 0) {
                exileBtn.style.display = 'block';
            } else {
                exileBtn.style.display = 'none';
            }

            // Show/hide actions based on zone ownership
            document.getElementById('zoneViewerActions').style.display = isMyZone ? 'flex' : 'none';

            currentZoneViewer = { zone: zoneName, seat: seat };
            document.getElementById('zoneViewerModal').classList.add('show');
        }

        function handleZoneCardClick(e, cardId, imageUrl, cardName, zoneName) {
            e.stopPropagation();

            // Shift+click for multi-select
            if (e.shiftKey) {
                if (zoneViewerSelection.has(cardId)) {
                    zoneViewerSelection.delete(cardId);
                    e.currentTarget.classList.remove('selected');
                } else {
                    zoneViewerSelection.add(cardId);
                    e.currentTarget.classList.add('selected');
                }
                updateZoneViewerActions();
                return;
            }

            // Regular click - show card modal
            showCard(cardId, imageUrl, cardName, zoneName, true);
        }

        function updateZoneViewerActions() {
            const count = zoneViewerSelection.size;
            const countEl = document.getElementById('zoneSelectionCount');
            const actionsEl = document.getElementById('zoneViewerActions');

            if (countEl) {
                countEl.textContent = count === 0 ? 'Nenhuma selecionada' : `${count} selecionada${count > 1 ? 's' : ''}`;
            }

            // Enable/disable buttons based on selection
            const buttons = actionsEl?.querySelectorAll('button');
            buttons?.forEach(btn => {
                if (!btn.textContent.includes('Limpar')) {
                    btn.disabled = count === 0;
                }
            });
        }

        function clearZoneSelection() {
            zoneViewerSelection.clear();
            document.querySelectorAll('#zoneViewerCards .card.selected').forEach(el => {
                el.classList.remove('selected');
            });
            updateZoneViewerActions();
        }

        function moveZoneSelectionTo(targetZone) {
            if (zoneViewerSelection.size === 0) return;

            const cardsToMove = [...zoneViewerSelection];
            cardsToMove.forEach(cardId => {
                if (targetZone === 'battlefield') {
                    const card = findCardById(cardId);
                    if (card && card.type_line) {
                        const row = getCardRow(card.type_line);
                        sendAction('move_card', { object_id: cardId, zone: targetZone, row: row });
                    } else {
                        sendAction('move_card', { object_id: cardId, zone: targetZone });
                    }
                } else {
                    sendAction('move_card', { object_id: cardId, zone: targetZone });
                }
            });

            zoneViewerSelection.clear();
            closeZoneViewer();
        }

        function handleZoneViewerDragStart(e, cardId, zoneName) {
            // If dragging a selected card, include all selected cards
            if (zoneViewerSelection.has(cardId) && zoneViewerSelection.size > 1) {
                draggedCards = new Set(zoneViewerSelection);
            } else {
                draggedCards.clear();
                draggedCards.add(cardId);
            }

            draggedCard = cardId;
            draggedCardData = { id: cardId, zone: zoneName };
            e.dataTransfer.setData('text/plain', cardId);
            e.dataTransfer.effectAllowed = 'move';
            e.target.classList.add('dragging');

            // Add visual feedback to all dragged cards
            draggedCards.forEach(id => {
                const el = document.querySelector(`#zoneViewerCards .card[data-id="${id}"]`);
                if (el) el.classList.add('dragging');
            });

            // Close zone viewer after a short delay to allow drag to start
            setTimeout(() => {
                closeZoneViewer();
                // Auto-open hand for dropping
                if (!handOpen) {
                    toggleHand();
                }
            }, 100);
        }

        function handleZoneViewerDragEnd(e) {
            document.querySelectorAll('.dragging').forEach(el => el.classList.remove('dragging'));
            draggedCard = null;
            draggedCardData = null;
            draggedCards.clear();
        }

        function showZoneCardContextMenu(e, cardId, zoneName) {
            e.preventDefault();
            e.stopPropagation();

            // Check if this card is part of a selection
            const isMultiSelect = zoneViewerSelection.has(cardId) && zoneViewerSelection.size > 1;
            const countLabel = isMultiSelect ? ` (${zoneViewerSelection.size})` : '';

            const items = [];

            if (zoneName === 'graveyard') {
                if (isMultiSelect) {
                    items.push({ label: `Mover para Mao${countLabel}`, action: `moveZoneSelectionTo('hand'); hideContextMenu();` });
                    items.push({ label: `Reanimar (Campo)${countLabel}`, action: `moveZoneSelectionTo('battlefield'); hideContextMenu();` });
                    items.push({ label: `Exilar${countLabel}`, action: `moveMultipleFromZone('exile'); hideContextMenu();` });
                } else {
                    items.push({ label: 'Devolver para Mao', action: `moveCardFromZone('${cardId}', 'hand'); hideContextMenu();` });
                    items.push({ label: 'Reanimar (Campo)', action: `moveCardFromZone('${cardId}', 'battlefield'); hideContextMenu();` });
                    items.push({ label: 'Exilar', action: `moveCardFromZone('${cardId}', 'exile'); hideContextMenu();` });
                    items.push({ divider: true });
                    items.push({ label: 'Topo do Deck', action: `sendAction('put_top', {object_id: '${cardId}'}); closeZoneViewer(); hideContextMenu();` });
                    items.push({ label: 'Fundo do Deck', action: `sendAction('put_bottom', {object_id: '${cardId}'}); closeZoneViewer(); hideContextMenu();` });
                    items.push({ label: 'Embaralhar no Deck', action: `sendAction('shuffle_into', {object_id: '${cardId}'}); closeZoneViewer(); hideContextMenu();` });
                }
            } else if (zoneName === 'exile') {
                if (isMultiSelect) {
                    items.push({ label: `Mover para Mao${countLabel}`, action: `moveZoneSelectionTo('hand'); hideContextMenu();` });
                    items.push({ label: `Mover para Campo${countLabel}`, action: `moveZoneSelectionTo('battlefield'); hideContextMenu();` });
                    items.push({ label: `Enviar Cemiterio${countLabel}`, action: `moveMultipleFromZone('graveyard'); hideContextMenu();` });
                } else {
                    items.push({ label: 'Devolver para Mao', action: `moveCardFromZone('${cardId}', 'hand'); hideContextMenu();` });
                    items.push({ label: 'Colocar no Campo', action: `moveCardFromZone('${cardId}', 'battlefield'); hideContextMenu();` });
                    items.push({ label: 'Enviar Cemiterio', action: `moveCardFromZone('${cardId}', 'graveyard'); hideContextMenu();` });
                    items.push({ divider: true });
                    items.push({ label: 'Topo do Deck', action: `sendAction('put_top', {object_id: '${cardId}'}); closeZoneViewer(); hideContextMenu();` });
                    items.push({ label: 'Fundo do Deck', action: `sendAction('put_bottom', {object_id: '${cardId}'}); closeZoneViewer(); hideContextMenu();` });
                    items.push({ label: 'Embaralhar no Deck', action: `sendAction('shuffle_into', {object_id: '${cardId}'}); closeZoneViewer(); hideContextMenu();` });
                }
            } else if (zoneName === 'command') {
                items.push({ label: 'Lancar no Campo', action: `moveCardFromZone('${cardId}', 'battlefield'); hideContextMenu();` });
            }

            if (items.length > 0) {
                showContextMenu(e, items, false);
            }
        }

        function moveMultipleFromZone(targetZone) {
            if (zoneViewerSelection.size === 0) return;

            const cardsToMove = [...zoneViewerSelection];
            cardsToMove.forEach(cardId => {
                sendAction('move_card', { object_id: cardId, zone: targetZone });
            });

            zoneViewerSelection.clear();
            // Refresh the zone viewer
            setTimeout(() => {
                if (currentZoneViewer.zone) {
                    showZoneViewer(currentZoneViewer.zone, currentZoneViewer.seat);
                }
            }, 300);
        }

        function moveCardFromZone(cardId, targetZone) {
            // Find card before sending action to use for optimistic visual update
            const card = findCardById(cardId);

            sendAction('move_card', { object_id: cardId, zone: targetZone });

            // If moving to battlefield, close zone viewer and add optimistic visual
            if (targetZone === 'battlefield') {
                closeZoneViewer();
                if (card && card.type_line) {
                    const row = getCardRow(card.type_line);
                    const cardData = {
                        id: cardId,
                        name: card.name,
                        type_line: card.type_line,
                        image_small: card.image_small || card.image_normal,
                        image_normal: card.image_normal,
                        is_tapped: false,
                        counters: {},
                        is_commander: card.is_commander || false
                    };
                    addCardToBattlefieldVisual(cardData, row, mySeat);
                }
            } else if (targetZone === 'hand') {
                // Close zone viewer when moving to hand
                closeZoneViewer();
            } else {
                // For other zones (exile, graveyard), refresh zone viewer after delay
                setTimeout(() => {
                    if (currentZoneViewer.zone) {
                        showZoneViewer(currentZoneViewer.zone, currentZoneViewer.seat);
                    }
                }, 300);
            }
        }

        function exileAllFromGraveyard() {
            if (currentZoneViewer.zone !== 'graveyard' || currentZoneViewer.seat !== mySeat) return;

            const zones = gameState.zones_data[mySeat];
            if (!zones || !zones.graveyard || zones.graveyard.length === 0) {
                closeZoneViewer();
                return;
            }

            // Move each card from graveyard to exile
            const cardIds = zones.graveyard.map(c => c.id);
            cardIds.forEach(cardId => {
                sendAction('move_card', { object_id: cardId, zone: 'exile' });
            });

            closeZoneViewer();
        }

        function showOpponentZone(seat, zoneName) {
            showZoneViewer(zoneName, seat);
        }

        function showCommanderCards(seat) {
            const zones = gameState.zones_data[seat];
            if (!zones || !zones.command || zones.command.length === 0) {
                alert('Comandante nao encontrado');
                return;
            }

            // If only one commander, show the card modal directly
            if (zones.command.length === 1) {
                const cmd = zones.command[0];
                showCard(cmd.id, cmd.image_normal, cmd.name, 'command', false);
            } else {
                // Multiple commanders (partner), show zone viewer
                showZoneViewer('command', seat);
            }
        }

        function closeZoneViewer() {
            document.getElementById('zoneViewerModal').classList.remove('show');
        }

        // Library Viewer
        let libraryViewerCards = [];

        function showLibraryViewerModal(cards) {
            libraryViewerCards = cards;
            renderLibraryViewer();
            document.getElementById('libraryViewerModal').classList.add('show');
        }

        function renderLibraryViewer() {
            document.getElementById('libraryViewerTitle').textContent = `Sua Biblioteca (${libraryViewerCards.length})`;
            document.getElementById('libraryViewerCards').innerHTML = libraryViewerCards.map(c => `
                <div class="card library-card" data-id="${c.id}"
                     onclick="showLibraryCardActions('${c.id}', '${c.image_normal}', '${c.name}')"
                     oncontextmenu="showLibraryCardContextMenu(event, '${c.id}', '${c.name}'); return false;">
                    <img src="${c.image_normal || c.image_small}" alt="${c.name}">
                </div>
            `).join('');
        }

        function showLibraryCardActions(cardId, imageUrl, cardName) {
            // Show card modal with library-specific actions
            selectedCard = { id: cardId, zone: 'library', name: cardName };
            document.getElementById('modalImage').src = imageUrl;
            document.getElementById('modalActions').innerHTML = `
                <button class="close" onclick="closeModal()">Fechar</button>
                <button class="action-btn" onclick="moveFromLibrary('${cardId}', 'hand')">Colocar na Mao</button>
                <button class="action-btn" onclick="moveFromLibrary('${cardId}', 'battlefield')">Colocar no Campo</button>
                <button class="action-btn" onclick="moveFromLibrary('${cardId}', 'graveyard')">Enviar ao Cemiterio</button>
                <button class="action-btn" onclick="moveFromLibrary('${cardId}', 'exile')">Exilar</button>
            `;
            document.getElementById('cardModal').classList.add('show');
        }

        function showLibraryCardContextMenu(e, cardId, cardName) {
            showContextMenu(e, [
                { label: 'Colocar na Mao', action: `moveFromLibrary('${cardId}', 'hand'); hideContextMenu();` },
                { label: 'Colocar no Campo', action: `moveFromLibrary('${cardId}', 'battlefield'); hideContextMenu();` },
                { divider: true },
                { label: 'Enviar ao Cemiterio', action: `moveFromLibrary('${cardId}', 'graveyard'); hideContextMenu();` },
                { label: 'Exilar', action: `moveFromLibrary('${cardId}', 'exile'); hideContextMenu();` },
                { divider: true },
                { label: 'Colocar no Topo', action: `sendAction('put_top', {object_id: '${cardId}'}); removeFromLibraryViewer('${cardId}'); hideContextMenu();` },
                { label: 'Colocar no Fundo', action: `sendAction('put_bottom', {object_id: '${cardId}'}); removeFromLibraryViewer('${cardId}'); hideContextMenu();` },
            ]);
        }

        function moveFromLibrary(cardId, zone) {
            closeModal();

            // Find the card in libraryViewerCards to get its type
            const card = libraryViewerCards.find(c => c.id === cardId);
            const data = { object_id: cardId, zone: zone };

            // When moving to battlefield, determine the row based on card type
            if (zone === 'battlefield' && card && card.type_line) {
                data.row = getCardRow(card.type_line);

                // Optimistic visual update - add card to battlefield immediately
                const cardData = {
                    id: cardId,
                    name: card.name,
                    type_line: card.type_line,
                    image_small: card.image_small || card.image_normal,
                    image_normal: card.image_normal,
                    is_tapped: false,
                    counters: {},
                    is_commander: false
                };
                addCardToBattlefieldVisual(cardData, data.row, mySeat);
            }

            sendAction('move_card', data);
            removeFromLibraryViewer(cardId);
        }

        function removeFromLibraryViewer(cardId) {
            libraryViewerCards = libraryViewerCards.filter(c => c.id !== cardId);
            renderLibraryViewer();
        }

        function closeLibraryViewer() {
            document.getElementById('libraryViewerModal').classList.remove('show');
            libraryViewerCards = [];
            // Auto shuffle when closing
            sendAction('shuffle_library');
            animateShuffle();
        }

        function showRevealAnimation(cardData) {
            document.getElementById('revealedCardImage').src = cardData.image_normal;
            document.getElementById('revealedCardText').textContent = `${cardData.player} revelou ${cardData.name}`;
            const overlay = document.getElementById('revealOverlay');
            overlay.classList.add('show');
            setTimeout(() => overlay.classList.remove('show'), 2500);
        }

        function animateShuffle() {
            const lib = document.getElementById('myLibrary');
            lib.classList.add('shuffling');
            setTimeout(() => lib.classList.remove('shuffling'), 500);
        }

        function showCard(objId, imageUrl, cardName, zone, isMe = false) {
            selectedCard = { id: objId, zone, name: cardName, image: imageUrl };
            document.getElementById('modalImage').src = imageUrl;

            let actions = '<button class="close" onclick="closeModal()">Fechar</button>';
            if (isMe) {
                if (zone === 'hand') {
                    actions += `
                        <button class="action-btn" onclick="moveCard('${objId}', 'battlefield')">Jogar</button>
                        <button class="action-btn" onclick="openAutopayFromModal('${objId}')">Auto-Pay </button>
                        <button class="action-btn" onclick="moveCard('${objId}', 'graveyard')">Descartar</button>
                        <button class="action-btn" onclick="moveCard('${objId}', 'exile')">Exilar</button>
                    `;
                } else if (zone === 'battlefield') {
                    actions += `
                        <button class="action-btn" onclick="toggleTap('${objId}')">Virar/Desvirar</button>
                        <button class="action-btn" onclick="moveCard('${objId}', 'graveyard')">Cemiterio</button>
                        <button class="action-btn" onclick="moveCard('${objId}', 'exile')">Exilar</button>
                        <button class="action-btn" onclick="moveCard('${objId}', 'hand')">Mao</button>
                        <button class="action-btn" onclick="moveCard('${objId}', 'command')">Zona Comando</button>
                        <button class="action-btn" onclick="startArrowFromCard('${objId}'); closeModal();">Criar Seta</button>
                    `;
                } else if (zone === 'command') {
                    actions += `<button class="action-btn" onclick="moveCard('${objId}', 'battlefield')">Lancar</button>`;
                } else if (zone === 'graveyard') {
                    actions += `
                        <button class="action-btn" onclick="moveCard('${objId}', 'hand')">Mao</button>
                        <button class="action-btn" onclick="moveCard('${objId}', 'battlefield')">Reanimar</button>
                        <button class="action-btn" onclick="moveCard('${objId}', 'exile')">Exilar</button>
                    `;
                } else if (zone === 'exile') {
                    actions += `
                        <button class="action-btn" onclick="moveCard('${objId}', 'hand')">Mao</button>
                        <button class="action-btn" onclick="moveCard('${objId}', 'battlefield')">Campo</button>
                    `;
                } else if (zone === 'library') {
                    actions += `
                        <button class="action-btn" onclick="moveCard('${objId}', 'hand')">Mao</button>
                        <button class="action-btn" onclick="moveCard('${objId}', 'battlefield')">Campo</button>
                        <button class="action-btn" onclick="moveCard('${objId}', 'graveyard')">Cemiterio</button>
                        <button class="action-btn" onclick="moveCard('${objId}', 'exile')">Exilar</button>
                    `;
                }
            }
            document.getElementById('modalActions').innerHTML = actions;
            document.getElementById('cardModal').classList.add('show');
        }

        function closeModal() {
            document.getElementById('cardModal').classList.remove('show');
            selectedCard = null;
        }

        // ===== GAME ACTIONS =====
        function moveCard(objId, zone, targetSeat = null, row = null) {
            closeModal();
            closeZoneViewer();
            const data = { object_id: objId, zone };
            if (targetSeat !== null) data.target_seat = targetSeat;

            // Get card and current zone before any modifications
            const card = findCardById(objId);
            const currentZone = findCardZone(objId);

            // Optimistic visual removal - check if card is on battlefield or hand and moving elsewhere
            if (currentZone === 'battlefield' && zone !== 'battlefield') {
                removeCardFromBattlefieldVisual(objId);
            } else if (currentZone === 'hand' && zone !== 'hand') {
                removeCardFromHandVisual(objId);
            }

            // When moving to battlefield, determine correct row based on card type
            if (zone === 'battlefield') {
                let targetRow = row;
                if (!targetRow && card && card.type_line) {
                    targetRow = getCardRow(card.type_line);
                }
                data.row = targetRow || 'enchantments'; // Default to enchantments if no type info

                // Optimistic visual addition - add card to battlefield immediately
                if (card && currentZone !== 'battlefield') {
                    addCardToBattlefieldVisual(card, data.row, targetSeat || mySeat);
                }
            }

            sendAction('move_card', data);
        }

        function changeLife(seat, delta) {
            sendAction('change_life', { target_seat: seat, delta });
        }

        function addCounter(objId) {
            closeModal();
            sendAction('add_counter', { object_id: objId, counter_type: '+1/+1' });
        }

        function removeCounter(objId) {
            closeModal();
            sendAction('remove_counter', { object_id: objId, counter_type: '+1/+1' });
        }

        // ===== EVENT LISTENERS =====
        document.getElementById('cardModal').addEventListener('click', function(e) {
            if (e.target === this) closeModal();
        });

        document.getElementById('zoneViewerModal').addEventListener('click', function(e) {
            if (e.target === this) closeZoneViewer();
        });

        document.getElementById('libraryViewerModal').addEventListener('click', function(e) {
            if (e.target === this) closeLibraryViewer();
        });

        document.getElementById('counterModal').addEventListener('click', function(e) {
            if (e.target === this) closeCounterModal();
        });

        document.addEventListener('keydown', function(e) {
            if (e.target.matches('input, textarea')) return;
            switch(e.key.toLowerCase()) {
                case 'escape':
                    closeModal();
                    closeZoneViewer();
                    closeScryModal();
                    closeCounterModal();
                    closeGuideModal();
                    closeKeywordsModal();
                    closeDiceModal();
                    closeStartSelection();
                    hideContextMenu();
                    cancelArrowMode(); // This already calls renderGame() for arrow state
                    selectedCards.clear();
                    updateCardSelectionVisual(); // Surgical update for selection clear
                    break;
                case 'd': drawCard(); break;
                case 'n': nextPhase(); break;
                case 'p': nextTurn(); break;
                case 's': shuffleLibrary(); break;
                case 'g': showZoneViewer('graveyard'); break;
                case 'e': showZoneViewer('exile'); break;
                case 'l': showLibraryMenu(); break;
                case 'c': toggleSidebar(); break;
                case 'x': clearAllArrows(); break;
                case 'h': openGuideModal(); break;
                case 'k': openKeywordsModal(); break;
                case 'r': openDiceModal(); break;
            }
        });

        // Redraw arrows on resize
        window.addEventListener('resize', renderArrows);

        if (tabId) {
            document.getElementById('lobbyLink').href = `/lobby/?tab=${tabId}`;
        }

        // ===== DICE ROLLER =====
        let diceHistory = [];

        function openDiceModal() {
            document.getElementById('diceModal').classList.add('show');
        }

        function closeDiceModal() {
            document.getElementById('diceModal').classList.remove('show');
        }

        function rollDice(sides) {
            const resultArea = document.getElementById('diceResultArea');

            // Show rolling animation
            resultArea.innerHTML = `<div class="dice-rolling">?</div><div class="dice-result-label">Rolando d${sides}...</div>`;

            let rollCount = 0;
            const maxRolls = 10;
            const rollInterval = setInterval(() => {
                const tempResult = Math.floor(Math.random() * sides) + 1;
                resultArea.querySelector('.dice-rolling').textContent = tempResult;
                rollCount++;

                if (rollCount >= maxRolls) {
                    clearInterval(rollInterval);
                    // Final result
                    const finalResult = Math.floor(Math.random() * sides) + 1;
                    resultArea.innerHTML = `
                        <div class="dice-result">${finalResult}</div>
                        <div class="dice-result-label">d${sides}</div>
                    `;

                    // Add to history and broadcast
                    addDiceToHistory(myNickname, sides, finalResult);
                    sendAction('roll_dice', { sides, result: finalResult });
                }
            }, 80);
        }

        function addDiceToHistory(player, sides, result) {
            diceHistory.unshift({ player, sides, result, time: new Date() });
            if (diceHistory.length > 10) diceHistory.pop();
            renderDiceHistory();
        }

        function renderDiceHistory() {
            const container = document.getElementById('diceHistory');
            container.innerHTML = diceHistory.map(h =>
                `<div class="dice-history-item">
                    <span class="player">${h.player}</span> rolou d${h.sides}: <span class="result">${h.result}</span>
                </div>`
            ).join('');
        }

        function showDiceNotification(player, sides, result) {
            // Create floating notification
            const notif = document.createElement('div');
            notif.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(22, 33, 62, 0.95);
                padding: 20px 40px;
                border-radius: 15px;
                border: 2px solid #9b59b6;
                z-index: 5000;
                text-align: center;
                animation: fadeIn 0.3s ease-out;
            `;
            notif.innerHTML = `
                <div style="color:#4ecdc4;font-size:0.9rem;margin-bottom:5px;">${player} rolou d${sides}</div>
                <div style="color:#ffc107;font-size:3rem;font-weight:bold;">${result}</div>
            `;
            document.body.appendChild(notif);

            setTimeout(() => {
                notif.style.animation = 'fadeIn 0.3s ease-out reverse';
                setTimeout(() => notif.remove(), 300);
            }, 2000);
        }

        document.getElementById('diceModal').addEventListener('click', function(e) {
            if (e.target === this) closeDiceModal();
        });

        // ===== STARTING PLAYER SELECTION =====
        let startSelectionActive = false;
        let playerRolls = {};

        function showStartSelection() {
            if (!gameState || !gameState.players) return;

            const modal = document.getElementById('startSelectionModal');
            const wheel = document.getElementById('startSelectionWheel');
            const players = gameState.players;
            const count = players.length;

            // Position players in a circle
            wheel.innerHTML = `<div class="wheel-center"></div>`;

            players.forEach((player, i) => {
                const angle = (i * (360 / count)) - 90; // Start from top
                const radian = angle * (Math.PI / 180);
                const radius = 110;
                const x = 150 + radius * Math.cos(radian) - 35;
                const y = 150 + radius * Math.sin(radian) - 35;

                wheel.innerHTML += `
                    <div class="wheel-player" id="wheelPlayer-${player.seat_position}"
                         style="left:${x}px; top:${y}px; background:${player.avatar_color};">
                        <span>${player.nickname.substring(0, 8)}</span>
                        <span class="roll-value" id="rollValue-${player.seat_position}">-</span>
                    </div>
                `;
            });

            playerRolls = {};
            startSelectionActive = true;
            document.getElementById('startRollBtn').disabled = false;
            document.getElementById('startRollBtn').textContent = ' Rolar para Decidir';
            document.getElementById('startResult').style.display = 'none';

            modal.classList.add('show');
        }

        function closeStartSelection() {
            document.getElementById('startSelectionModal').classList.remove('show');
            startSelectionActive = false;
        }

        function startRollForFirst() {
            if (!gameState || !gameState.players) return;

            const btn = document.getElementById('startRollBtn');
            btn.disabled = true;
            btn.textContent = 'Rolando...';

            const players = gameState.players;
            playerRolls = {};

            // Add rolling animation to all players
            players.forEach(p => {
                const el = document.getElementById(`wheelPlayer-${p.seat_position}`);
                if (el) el.classList.add('rolling');
            });

            // Animate rolling for each player with staggered timing
            let completedRolls = 0;

            players.forEach((player, index) => {
                setTimeout(() => {
                    animatePlayerRoll(player.seat_position, () => {
                        completedRolls++;
                        if (completedRolls === players.length) {
                            determineWinner();
                        }
                    });
                }, index * 500);
            });
        }

        function animatePlayerRoll(seat, callback) {
            const valueEl = document.getElementById(`rollValue-${seat}`);
            const playerEl = document.getElementById(`wheelPlayer-${seat}`);

            let rollCount = 0;
            const maxRolls = 15;

            const rollInterval = setInterval(() => {
                const tempResult = Math.floor(Math.random() * 20) + 1;
                valueEl.textContent = tempResult;
                rollCount++;

                if (rollCount >= maxRolls) {
                    clearInterval(rollInterval);
                    const finalResult = Math.floor(Math.random() * 20) + 1;
                    valueEl.textContent = finalResult;
                    playerRolls[seat] = finalResult;
                    playerEl.classList.remove('rolling');
                    callback();
                }
            }, 60);
        }

        function determineWinner() {
            const players = gameState.players;

            // Find highest roll
            let maxRoll = 0;
            let winners = [];

            for (const [seat, roll] of Object.entries(playerRolls)) {
                if (roll > maxRoll) {
                    maxRoll = roll;
                    winners = [parseInt(seat)];
                } else if (roll === maxRoll) {
                    winners.push(parseInt(seat));
                }
            }

            // Handle ties
            if (winners.length > 1) {
                document.getElementById('startResult').innerHTML =
                    `<span style="color:#e94560;">Empate! Role novamente.</span>`;
                document.getElementById('startResult').style.display = 'block';
                document.getElementById('startRollBtn').disabled = false;
                document.getElementById('startRollBtn').textContent = ' Rolar Novamente';
                return;
            }

            const winnerSeat = winners[0];
            const winner = players.find(p => p.seat_position === winnerSeat);

            // Highlight winner
            document.getElementById(`wheelPlayer-${winnerSeat}`).classList.add('winner');

            // Show result
            document.getElementById('startResult').innerHTML =
                ` <strong>${winner.nickname}</strong> comeca! (rolou ${maxRoll})`;
            document.getElementById('startResult').style.display = 'block';

            // Broadcast the result
            sendAction('set_starting_player', { seat: winnerSeat, roll: maxRoll });

            // Close after delay
            setTimeout(() => {
                closeStartSelection();
            }, 3000);
        }

        document.getElementById('startSelectionModal').addEventListener('click', function(e) {
            if (e.target === this && !startSelectionActive) closeStartSelection();
        });

        // ===== GUIDE MODAL =====
        function openGuideModal() {
            document.getElementById('guideModal').classList.add('show');
        }

        function closeGuideModal() {
            document.getElementById('guideModal').classList.remove('show');
        }

        function showGuideTab(tabName) {
            document.querySelectorAll('.guide-tab-content').forEach(el => el.style.display = 'none');
            document.querySelectorAll('.help-tab').forEach(el => el.classList.remove('active'));
            document.getElementById('guideTab-' + tabName).style.display = 'block';
            event.target.classList.add('active');
        }

        document.getElementById('guideModal').addEventListener('click', function(e) {
            if (e.target === this) closeGuideModal();
        });

        // ===== KEYWORDS MODAL =====
        const KEYWORDS_DATA = [
            // Evergreen Keywords
            { name: 'Flying', category: 'evasion', desc: 'Esta criatura so pode ser bloqueada por criaturas com voar ou alcance.', example: 'Serra Angel tem voar e vigilancia.' },
            { name: 'First Strike', category: 'combat', desc: 'Esta criatura causa dano de combate antes de criaturas sem iniciativa.', example: 'Cavaleiros geralmente tem iniciativa.' },
            { name: 'Double Strike', category: 'combat', desc: 'Esta criatura causa dano de combate na etapa de iniciativa E na etapa normal.', example: 'Efetivamente dobra o dano de combate.' },
            { name: 'Deathtouch', category: 'combat', desc: 'Qualquer quantidade de dano que esta criatura cause a outra criatura e suficiente para destrui-la.', example: '1 dano de uma criatura com toque mortifero mata qualquer criatura.' },
            { name: 'Trample', category: 'combat', desc: 'Se esta criatura causaria dano suficiente aos seus bloqueadores para destrui-los, voce pode fazer o dano excedente ao jogador ou planeswalker.', example: 'Criatura 6/6 com atropelar bloqueada por 2/2 causa 4 dano ao jogador.' },
            { name: 'Haste', category: 'evergreen', desc: 'Esta criatura pode atacar e usar habilidades de tap no turno em que entrou no campo.', example: 'Criaturas vermelhas frequentemente tem impeto.' },
            { name: 'Vigilance', category: 'evergreen', desc: 'Atacar com esta criatura nao faz ela virar.', example: 'Permite atacar e ainda bloquear no proximo turno.' },
            { name: 'Reach', category: 'evasion', desc: 'Esta criatura pode bloquear criaturas com voar.', example: 'Aranhas geralmente tem alcance.' },
            { name: 'Lifelink', category: 'evergreen', desc: 'Dano causado por esta criatura tambem faz voce ganhar essa quantidade de vida.', example: 'Atacar com 3/3 lifelink da 3 vida.' },
            { name: 'Menace', category: 'evasion', desc: 'Esta criatura so pode ser bloqueada por duas ou mais criaturas.', example: 'Forca o oponente a usar mais recursos para bloquear.' },
            { name: 'Hexproof', category: 'protection', desc: 'Esta permanente nao pode ser alvo de magias ou habilidades que seus oponentes controlam.', example: 'Protege contra remocoes direcionadas do oponente.' },
            { name: 'Shroud', category: 'protection', desc: 'Esta permanente nao pode ser alvo de magias ou habilidades.', example: 'Nem voce nem oponentes podem mirar nela.' },
            { name: 'Indestructible', category: 'protection', desc: 'Esta permanente nao pode ser destruida. Dano e efeitos que dizem "destrua" nao funcionam.', example: 'Ainda pode ser exilada ou sacrificada.' },
            { name: 'Flash', category: 'evergreen', desc: 'Voce pode conjurar esta magia a qualquer momento que pudesse conjurar um instantaneo.', example: 'Permite surpresas no turno do oponente.' },
            { name: 'Defender', category: 'static', desc: 'Esta criatura nao pode atacar.', example: 'Muralhas geralmente tem defensor.' },
            { name: 'Ward', category: 'protection', desc: 'Sempre que esta permanente se tornar alvo de uma magia ou habilidade de um oponente, anule-a a menos que aquele jogador pague o custo.', example: 'Ward 2 exige pagar 2 mana extra para mirar.' },

            // Triggered Abilities
            { name: 'Enters the Battlefield (ETB)', category: 'triggered', desc: 'Habilidade que dispara quando a permanente entra no campo de batalha.', example: '"Quando ~ entra no campo, compre uma carta."' },
            { name: 'Dies', category: 'triggered', desc: 'Habilidade que dispara quando a criatura vai do campo para o cemiterio.', example: '"Quando ~ morre, crie um token 1/1."' },
            { name: 'Landfall', category: 'triggered', desc: 'Habilidade que dispara sempre que um terreno entra no campo sob seu controle.', example: 'Muito comum em decks de ramp verde.' },
            { name: 'Cascade', category: 'triggered', desc: 'Ao conjurar, exile cartas do topo ate revelar nao-terreno com custo menor, pode conjurar de graca.', example: 'Cascade e muito poderoso em Commander.' },
            { name: 'Annihilator', category: 'triggered', desc: 'Quando esta criatura ataca, o jogador defensor sacrifica X permanentes.', example: 'Eldrazi Titans tem Annihilator.' },

            // Mana Abilities
            { name: 'Convoke', category: 'mana', desc: 'Suas criaturas podem ajudar a pagar esta magia. Cada criatura virada paga 1 ou uma cor de mana.', example: 'Virar 3 criaturas reduz o custo em 3.' },
            { name: 'Delve', category: 'mana', desc: 'Cada carta exilada do seu cemiterio paga 1 mana generico do custo.', example: 'Treasure Cruise pode custar apenas U.' },
            { name: 'Affinity', category: 'mana', desc: 'Esta magia custa 1 a menos para cada [tipo] que voce controla.', example: 'Affinity for artifacts e muito forte.' },
            { name: 'Improvise', category: 'mana', desc: 'Seus artefatos podem ajudar a pagar esta magia virar artefato = 1 mana.', example: 'Similar a Convoke mas para artefatos.' },

            // Static Abilities
            { name: 'Changeling', category: 'static', desc: 'Esta carta e de todos os tipos de criatura.', example: 'Conta como Elfo, Goblin, Dragao, etc.' },
            { name: 'Partner', category: 'static', desc: 'Voce pode ter dois comandantes se ambos tiverem Partner.', example: 'Comum em Commander para combos.' },
            { name: 'Eminence', category: 'static', desc: 'Habilidade que funciona enquanto o comandante esta na zona de comando ou no campo.', example: 'Nao precisa lancar o comandante.' },
            { name: 'Companion', category: 'static', desc: 'Se seu deck inicial atender a condicao, pode ter esta carta como companion.', example: 'Companion tem restricoes de deckbuilding.' },

            // Protection & Evasion
            { name: 'Protection', category: 'protection', desc: 'Nao pode ser bloqueado, alvo, encantado/equipado ou receber dano da qualidade especificada.', example: 'Protection from red = imune a tudo vermelho.' },
            { name: 'Unblockable', category: 'evasion', desc: 'Esta criatura nao pode ser bloqueada.', example: 'Rogues frequentemente sao unblockaveis.' },
            { name: 'Shadow', category: 'evasion', desc: 'So pode bloquear e ser bloqueada por criaturas com sombra.', example: 'Criaturas com sombra ignoram bloqueadores normais.' },
            { name: 'Horsemanship', category: 'evasion', desc: 'So pode ser bloqueada por criaturas com horsemanship.', example: 'Versao antiga e rara de evasao.' },
            { name: 'Fear', category: 'evasion', desc: 'So pode ser bloqueada por criaturas de artefato ou pretas.', example: 'Substituido por Intimidate e depois Menace.' },
            { name: 'Intimidate', category: 'evasion', desc: 'So pode ser bloqueada por criaturas de artefato ou que compartilhem uma cor.', example: 'Criatura vermelha com intimidate so bloqueada por vermelhas ou artefatos.' },
            { name: 'Skulk', category: 'evasion', desc: 'So pode ser bloqueada por criaturas com poder maior ou igual.', example: 'Bom em criaturas pequenas.' },

            // Counters & Modifiers
            { name: '+1/+1 Counter', category: 'counter', desc: 'Marcador que da +1 poder e +1 resistencia permanentemente.', example: 'Muitas cartas adicionam ou interagem com +1/+1.' },
            { name: '-1/-1 Counter', category: 'counter', desc: 'Marcador que da -1 poder e -1 resistencia permanentemente.', example: 'Anula marcadores +1/+1 quando ambos existem.' },
            { name: 'Poison Counter', category: 'counter', desc: 'Marcador dado a jogadores. 10 ou mais = derrota.', example: 'Criaturas com Infect dao veneno.' },
            { name: 'Experience Counter', category: 'counter', desc: 'Marcador em jogador que nunca e removido.', example: 'Alguns comandantes usam experiencia.' },
            { name: 'Energy Counter', category: 'counter', desc: 'Recurso alternativo que persiste entre turnos.', example: 'Introduzido em Kaladesh.' },
            { name: 'Loyalty Counter', category: 'counter', desc: 'Marcadores em Planeswalkers. Determina vida e habilidades.', example: 'Planeswalkers entram com X lealdade.' },

            // Combat Keywords
            { name: 'Infect', category: 'combat', desc: 'Causa dano a criaturas como -1/-1 e a jogadores como veneno.', example: 'Muito forte pois conta separado da vida.' },
            { name: 'Wither', category: 'combat', desc: 'Dano a criaturas e causado como marcadores -1/-1.', example: 'Versao mais fraca de Infect.' },
            { name: 'Provoke', category: 'combat', desc: 'Quando ataca, pode forcar uma criatura a bloquear.', example: 'Util para remover criaturas problematicas.' },
            { name: 'Rampage', category: 'combat', desc: 'Ganha +X/+X para cada criatura alem da primeira que a bloqueia.', example: 'Rampage 2 = +2/+2 por bloqueador extra.' },
            { name: 'Flanking', category: 'combat', desc: 'Quando bloqueada por criatura sem flanquear, o bloqueador recebe -1/-1.', example: 'Cavaleiros de Mirage tem flanquear.' },
            { name: 'Banding', category: 'combat', desc: 'Criaturas com bando podem atacar ou bloquear juntas. Voce divide o dano.', example: 'Mecanica antiga e complexa.' },
            { name: 'Bushido', category: 'combat', desc: 'Quando bloqueia ou e bloqueada, ganha +X/+X ate fim do turno.', example: 'Samurais de Kamigawa tem Bushido.' },
            { name: 'Ninjutsu', category: 'combat', desc: 'Pague custo e devolva atacante nao bloqueado para por esta carta atacando.', example: 'Ninjas entram ja causando dano.' },
            { name: 'Exalted', category: 'combat', desc: 'Quando uma criatura que voce controla ataca sozinha, ela ganha +1/+1 para cada Exalted.', example: 'Multiplos Exalted acumulam.' },
            { name: 'Battle Cry', category: 'combat', desc: 'Quando ataca, outras criaturas atacantes ganham +1/+0.', example: 'Bom com muitas criaturas.' },
            { name: 'Myriad', category: 'combat', desc: 'Quando ataca, crie copias atacando cada outro oponente.', example: 'Excelente em multiplayer/Commander.' },
            { name: 'Melee', category: 'combat', desc: 'Ganha +1/+1 para cada oponente que voce atacou este combate.', example: 'Melhor quanto mais oponentes.' },
            { name: 'Goad', category: 'combat', desc: 'Criatura provocada deve atacar oponente diferente de voce se possivel.', example: 'Forca oponentes a se atacarem.' },

            // Spell Keywords
            { name: 'Kicker', category: 'mana', desc: 'Custo adicional opcional. Se pago, a magia tem efeito extra.', example: 'Kicker torna magias mais flexiveis.' },
            { name: 'Flashback', category: 'triggered', desc: 'Pode ser conjurada do cemiterio pelo custo de flashback, depois e exilada.', example: 'Da uma segunda chance a magias.' },
            { name: 'Overload', category: 'mana', desc: 'Custo alternativo que muda "alvo" para "cada".', example: 'Cyclonic Rift com overload devolve TUDO.' },
            { name: 'Splice', category: 'mana', desc: 'Ao conjurar magia do tipo, pode revelar esta e pagar splice para adicionar efeito.', example: 'Splice onto Arcane e o mais comum.' },
            { name: 'Storm', category: 'triggered', desc: 'Ao conjurar, copie para cada magia conjurada antes neste turno.', example: 'Storm e uma das mecanicas mais fortes.' },
            { name: 'Replicate', category: 'mana', desc: 'Pague o custo quantas vezes quiser, copie a magia esse numero de vezes.', example: 'Permite escalar magias.' },
            { name: 'Conspire', category: 'mana', desc: 'Vire duas criaturas da mesma cor para copiar a magia.', example: 'Bom com tokens.' },
            { name: 'Retrace', category: 'triggered', desc: 'Pode conjurar do cemiterio descartando um terreno como custo adicional.', example: 'Terrenos viram combustivel.' },
            { name: 'Rebound', category: 'triggered', desc: 'Se conjurada da mao, exile e conjure de graca no proximo turno.', example: 'Duas magias pelo preco de uma.' },
            { name: 'Miracle', category: 'mana', desc: 'Se for a primeira carta comprada no turno, pode conjurar pelo custo de milagre.', example: 'Terminus por W limpa o campo.' },
            { name: 'Madness', category: 'mana', desc: 'Se descartada, pode conjurar pelo custo de loucura em vez de ir pro cemiterio.', example: 'Transforma descarte em vantagem.' },
            { name: 'Escape', category: 'mana', desc: 'Pode conjurar do cemiterio pelo custo de escape, exilando outras cartas.', example: 'Cemiterio vira recurso.' },
            { name: 'Foretell', category: 'mana', desc: 'Pague 2 para exilar virada. Depois pode conjurar pelo custo de presagio.', example: 'Permite planejar turnos futuros.' },

            // Other Abilities
            { name: 'Equip', category: 'static', desc: 'Pague o custo para anexar este equipamento a criatura que controla.', example: 'Equipamentos passam de criatura para criatura.' },
            { name: 'Enchant', category: 'static', desc: 'Esta aura so pode ser anexada ao tipo especificado.', example: 'Enchant creature = so em criaturas.' },
            { name: 'Regenerate', category: 'evergreen', desc: 'Pague custo: da proxima vez que seria destruida, vira, remove de combate, remove dano.', example: 'Mecanica antiga, substituida por outros efeitos.' },
            { name: 'Phasing', category: 'static', desc: 'No inicio do turno, permanentes com phasing alternam entre existir e nao existir.', example: 'Enquanto phased out, e como se nao existisse.' },
            { name: 'Morph', category: 'evergreen', desc: 'Pode conjurar virada para baixo como 2/2 por 3. Vire para cima pagando custo de metamorfose.', example: 'Esconde a identidade da criatura.' },
            { name: 'Manifest', category: 'static', desc: 'Coloque a carta do topo virada para baixo como 2/2. Se for criatura, pode virar pelo custo de mana.', example: 'Similar a Morph mas aleatorio.' },
            { name: 'Mutate', category: 'mana', desc: 'Pague custo de mutacao para fundir com criatura nao-humana. Combinam poder/resistencia e habilidades.', example: 'Cria criaturas customizadas.' },
            { name: 'Cycling', category: 'mana', desc: 'Descarte esta carta e pague custo para comprar uma carta.', example: 'Troca cartas desnecessarias.' },
            { name: 'Transmute', category: 'mana', desc: 'Descarte e pague custo para buscar carta com mesmo custo de mana convertido.', example: 'Tutor para custo especifico.' },
            { name: 'Scry', category: 'evergreen', desc: 'Olhe as X cartas do topo. Coloque quantas quiser no fundo em qualquer ordem.', example: 'Scry 2 = olhe 2, decida onde vao.' },
            { name: 'Surveil', category: 'evergreen', desc: 'Olhe X cartas do topo. Coloque quantas quiser no cemiterio, resto no topo.', example: 'Como Scry mas para o cemiterio.' },
            { name: 'Explore', category: 'triggered', desc: 'Revele o topo. Se terreno, coloque na mao. Se nao, +1/+1 e pode colocar no cemiterio.', example: 'Gera vantagem de cartas ou criaturas maiores.' },
            { name: 'Populate', category: 'triggered', desc: 'Crie uma copia de um token de criatura que voce controla.', example: 'Duplica seus melhores tokens.' },
            { name: 'Proliferate', category: 'triggered', desc: 'Escolha permanentes e jogadores com marcadores. De mais um de cada tipo que ja tem.', example: 'Aumenta +1/+1, veneno, lealdade, etc.' },
            { name: 'Amass', category: 'triggered', desc: 'Coloque +1/+1 em Exercito que controla ou crie token Exercito Zumbi 0/0 primeiro.', example: 'Cria um exercito cada vez maior.' },
            { name: 'Monstrosity', category: 'mana', desc: 'Se nao for monstruosa, coloque X +1/+1 e torna-se monstruosa.', example: 'So pode ser ativado uma vez.' },
            { name: 'Adapt', category: 'mana', desc: 'Se nao tiver +1/+1, coloque X marcadores +1/+1.', example: 'Pode ser reativado se perder marcadores.' },
            { name: 'Crew', category: 'mana', desc: 'Vire criaturas com poder total X ou mais para tornar este Veiculo criatura ate fim do turno.', example: 'Veiculos precisam ser tripulados.' },
            { name: 'Fabricate', category: 'triggered', desc: 'Ao entrar, escolha: +1/+1 ou criar token Servo 1/1 artefato.', example: 'Flexibilidade entre tamanho ou quantidade.' },
            { name: 'Embalm', category: 'mana', desc: 'Exile do cemiterio: crie token copia branca zumbi sem custo de mana.', example: 'Criaturas voltam como zumbis.' },
            { name: 'Eternalize', category: 'mana', desc: 'Exile do cemiterio: crie token copia preta zumbi 4/4 sem custo de mana.', example: 'Versao mais forte de Embalm.' },
            { name: 'Encore', category: 'mana', desc: 'Exile do cemiterio: crie copias igual ao numero de oponentes, atacam esse turno, sacrificam no fim.', example: 'Otimo em multiplayer.' },
            { name: 'Unearth', category: 'mana', desc: 'Devolva do cemiterio ao campo com impeto. Exile no fim do turno ou se deixar o campo.', example: 'Um ultimo ataque do cemiterio.' },
            { name: 'Persist', category: 'triggered', desc: 'Quando morre sem -1/-1, volta com um marcador -1/-1.', example: 'Criaturas voltam uma vez menores.' },
            { name: 'Undying', category: 'triggered', desc: 'Quando morre sem +1/+1, volta com um marcador +1/+1.', example: 'Criaturas voltam uma vez maiores.' },
            { name: 'Blitz', category: 'mana', desc: 'Custo alternativo: ganha impeto, compre ao morrer, sacrifica no fim do turno.', example: 'Ataque rapido com recompensa.' },
            { name: 'Hideaway', category: 'triggered', desc: 'Entra virado. Ao entrar, olhe 4 cartas do topo, exile uma virada, resto vai pro fundo.', example: 'Terrenos hideaway guardam surpresas.' },
            { name: 'Evoke', category: 'mana', desc: 'Custo alternativo. Se pago, sacrifique quando entrar no campo.', example: 'Pague menos por efeito temporario.' },
            { name: 'Champion', category: 'triggered', desc: 'Ao entrar, exile criatura do tipo. Quando sair, ela volta.', example: 'Temporariamente substitui outra criatura.' },
            { name: 'Soulbond', category: 'triggered', desc: 'Pode parear com outra criatura sem par. Ambas ganham habilidade enquanto pareadas.', example: 'Criaturas trabalham em dupla.' },
            { name: 'Bestow', category: 'mana', desc: 'Pode conjurar como Aura pelo custo de concessao. Se criatura encantada sair, vira criatura.', example: 'Criatura que vira aura e vice-versa.' },
            { name: 'Living Weapon', category: 'triggered', desc: 'Ao entrar, crie token Germe 0/0 preto e anexe este equipamento a ele.', example: 'Equipamento que vem com criatura.' },
            { name: 'Reconfigure', category: 'mana', desc: 'Pode anexar/desanexar de criatura. Enquanto anexado, nao e criatura.', example: 'Criatura que vira equipamento.' },
            { name: 'Suspend', category: 'mana', desc: 'Exile com X marcadores de tempo. A cada manutencao, remova um. Sem marcadores, conjure de graca.', example: 'Pague tempo em vez de mana.' },
            { name: 'Vanishing', category: 'triggered', desc: 'Entra com X marcadores de tempo. Remova um cada manutencao. Sem marcadores, sacrifique.', example: 'Permanentes temporarias.' },
            { name: 'Fading', category: 'triggered', desc: 'Entra com X marcadores. Remova um cada manutencao. Sem marcadores, sacrifique.', example: 'Versao antiga de Vanishing.' },
            { name: 'Modular', category: 'triggered', desc: 'Entra com X +1/+1. Quando morre, pode mover os marcadores para criatura artefato.', example: 'Marcadores passam para frente.' },
            { name: 'Sunburst', category: 'triggered', desc: 'Entra com +1/+1 ou marcador de carga para cada cor de mana gasta.', example: 'Recompensa decks multicoloridos.' },
            { name: 'Devour', category: 'triggered', desc: 'Ao entrar, pode sacrificar criaturas. Ganha +1/+1 para cada devorada (ou mais).', example: 'Criaturas pequenas viram +1/+1.' },
            { name: 'Graft', category: 'triggered', desc: 'Entra com X +1/+1. Quando outra criatura entra, pode mover um marcador para ela.', example: 'Compartilha marcadores com novatos.' },
            { name: 'Entwine', category: 'mana', desc: 'Custo adicional para escolher todos os modos em vez de apenas um.', example: 'Pague mais para fazer tudo.' },
            { name: 'Fuse', category: 'static', desc: 'Pode conjurar um ou ambos os lados de cartas split. Se conjurar ambos, pague os dois custos.', example: 'Cartas split com Fuse sao flexiveis.' },
            { name: 'Aftermath', category: 'static', desc: 'Este lado so pode ser conjurado do cemiterio, depois e exilado.', example: 'Segunda metade da carta split.' },
            { name: 'Adventure', category: 'static', desc: 'Pode conjurar como instantaneo/feitico primeiro. Do exilio, pode conjurar a criatura.', example: 'Duas magias em uma carta.' },
            { name: 'Toxic', category: 'combat', desc: 'Quando causa dano de combate a jogador, esse jogador recebe X marcadores de veneno.', example: 'Versao mais controlada de Infect.' },
            { name: 'Corrupted', category: 'static', desc: 'Habilidade ativa se oponente tem 3+ marcadores de veneno.', example: 'Bonus contra jogadores envenenados.' },
            { name: 'For Mirrodin!', category: 'triggered', desc: 'Ao entrar, crie token Rebelde 2/2 vermelho e anexe este equipamento a ele.', example: 'Similar a Living Weapon.' },
            { name: 'Compleated', category: 'mana', desc: 'Pode ser pago com 2 vida em vez de mana Phyrexiano. Se pago com vida, entra com menos lealdade.', example: 'Planeswalkers Phyrexianos.' },
            { name: 'Prototype', category: 'mana', desc: 'Custo alternativo menor para versao menor da criatura (diferente P/T e cor).', example: 'Criaturas com duas versoes.' },
            { name: 'Stun Counter', category: 'counter', desc: 'Se permanente com stun counter desvira, remova um marcador em vez de desvirar.', example: 'Mantem criaturas viradas mais tempo.' },
            { name: 'Incubate', category: 'triggered', desc: 'Crie token Incubadora artefato com X +1/+1. Pague 2 para transforma-lo em criatura 0/0 Phyrexiana.', example: 'Criaturas que crescem de ovos.' },
            { name: 'Role Token', category: 'triggered', desc: 'Auras token com varios efeitos (Cursed, Monster, Royal, etc). So uma por criatura.', example: 'Introducido em Wilds of Eldraine.' },
            { name: 'Bargain', category: 'mana', desc: 'Pode sacrificar artefato, encantamento ou token como custo adicional para efeito bonus.', example: 'Sacrificio para poder extra.' },
            { name: 'Celebration', category: 'triggered', desc: 'Ativa se duas ou mais permanentes nao-terreno entraram sob seu controle este turno.', example: 'Recompensa jogar multiplas cartas.' }
        ];

        let activeCategory = 'all';

        function openKeywordsModal() {
            renderKeywords();
            document.getElementById('keywordsModal').classList.add('show');
            document.getElementById('keywordSearch').value = '';
            document.getElementById('keywordSearch').focus();
        }

        function closeKeywordsModal() {
            document.getElementById('keywordsModal').classList.remove('show');
        }

        function renderKeywords() {
            const grid = document.getElementById('keywordsGrid');
            const searchTerm = document.getElementById('keywordSearch').value.toLowerCase();

            const filtered = KEYWORDS_DATA.filter(kw => {
                const matchesSearch = kw.name.toLowerCase().includes(searchTerm) ||
                                      kw.desc.toLowerCase().includes(searchTerm);
                const matchesCategory = activeCategory === 'all' || kw.category === activeCategory;
                return matchesSearch && matchesCategory;
            });

            grid.innerHTML = filtered.map(kw => `
                <div class="keyword-item">
                    <div class="keyword-name">
                        ${kw.name}
                        <span class="keyword-category ${kw.category}">${kw.category}</span>
                    </div>
                    <div class="keyword-desc">${kw.desc}</div>
                    ${kw.example ? `<div class="keyword-example">${kw.example}</div>` : ''}
                </div>
            `).join('');

            document.getElementById('keywordsCount').textContent = `Mostrando ${filtered.length} de ${KEYWORDS_DATA.length} keywords`;
        }

        function filterKeywords() {
            renderKeywords();
        }

        function filterByCategory(category) {
            activeCategory = category;
            document.querySelectorAll('.category-filter').forEach(el => el.classList.remove('active'));
            event.target.classList.add('active');
            renderKeywords();
        }

        document.getElementById('keywordsModal').addEventListener('click', function(e) {
            if (e.target === this) closeKeywordsModal();
        });

        // ===== AUTO-PAY MANA SYSTEM =====
        let autopayCard = null;
        let autopayLandsToTap = [];
        let autopayPendingMultiSelections = [];
        let autopayManaPool = { W: 0, U: 0, B: 0, R: 0, G: 0, C: 0 };

        // Parse mana cost string like "{2}{G}{G}" into an object
        function parseManaCost(manaCost) {
            if (!manaCost) return { total: 0, colored: {}, generic: 0, colorless: 0 };

            const result = { total: 0, colored: { W: 0, U: 0, B: 0, R: 0, G: 0 }, generic: 0, colorless: 0 };
            const symbols = manaCost.match(/\{[^}]+\}/g) || [];

            symbols.forEach(sym => {
                const inner = sym.slice(1, -1);
                if (/^\d+$/.test(inner)) {
                    result.generic += parseInt(inner);
                    result.total += parseInt(inner);
                } else if (inner === 'C') {
                    result.colorless += 1;
                    result.total += 1;
                } else if (inner === 'X') {
                    // X costs are handled specially - for now we treat as 0
                } else if (['W', 'U', 'B', 'R', 'G'].includes(inner)) {
                    result.colored[inner] = (result.colored[inner] || 0) + 1;
                    result.total += 1;
                } else if (inner.includes('/')) {
                    // Hybrid mana like {W/U} or {2/W}
                    result.total += 1;
                    // Store as special hybrid
                    if (!result.hybrid) result.hybrid = [];
                    result.hybrid.push(inner.split('/'));
                }
            });

            return result;
        }

        // Render mana cost symbols as HTML
        function renderManaCostSymbols(manaCost) {
            if (!manaCost) return '';
            const symbols = manaCost.match(/\{[^}]+\}/g) || [];

            return symbols.map(sym => {
                const inner = sym.slice(1, -1);
                if (/^\d+$/.test(inner)) {
                    return `<span class="mana-symbol generic">${inner}</span>`;
                } else if (inner === 'C') {
                    return `<span class="mana-symbol C">C</span>`;
                } else if (['W', 'U', 'B', 'R', 'G'].includes(inner)) {
                    return `<span class="mana-symbol ${inner}">${inner}</span>`;
                } else if (inner === 'X') {
                    return `<span class="mana-symbol generic">X</span>`;
                } else {
                    return `<span class="mana-symbol generic">${inner}</span>`;
                }
            }).join('');
        }

        // Get detailed mana ability info including activation cost
        // Handles Signets, Talismans, and other pay-to-activate mana sources
        function getManaAbilityInfo(card) {
            const typeLine = (card.type_line || '').toLowerCase();
            const oracleText = (card.oracle_text || '').toLowerCase();
            const name = (card.name || '').toLowerCase();

            const result = {
                colors: [],
                activationCost: 0,      // Generic mana cost to activate
                activationColor: null,  // If requires specific color to activate
                isFree: true,           // True if just tap, false if requires mana payment
                manaProduced: 1,        // How many mana symbols it produces
                netMana: 1              // Net mana gain (produced - cost)
            };

            // Check for pay-to-activate patterns like "{1}, {t}: add" or "{2}, {t}: add"
            const payToActivateMatch = oracleText.match(/\{(\d+)\},?\s*\{t\}:\s*add/);
            if (payToActivateMatch) {
                result.activationCost = parseInt(payToActivateMatch[1]);
                result.isFree = false;
            }

            // Also check for colored mana cost like "{g}, {t}: add"
            const coloredCostMatch = oracleText.match(/\{([wubrgc])\},?\s*\{t\}:\s*add/);
            if (coloredCostMatch) {
                result.activationCost = 1;
                result.isFree = false;
                result.activationColor = coloredCostMatch[1].toUpperCase();
            }

            // Basic lands are always free
            if (typeLine.includes('basic') && typeLine.includes('land')) {
                result.isFree = true;
                result.activationCost = 0;
            }

            // Regular lands with just "{t}: add" are free
            if (typeLine.includes('land') && oracleText.match(/\{t\}:\s*add/) && !payToActivateMatch && !coloredCostMatch) {
                result.isFree = true;
                result.activationCost = 0;
            }

            // Detect mana colors produced from type line
            if (typeLine.includes('plains') || name.includes('plains')) result.colors.push('W');
            if (typeLine.includes('island') || name.includes('island')) result.colors.push('U');
            if (typeLine.includes('swamp') || name.includes('swamp')) result.colors.push('B');
            if (typeLine.includes('mountain') || name.includes('mountain')) result.colors.push('R');
            if (typeLine.includes('forest') || name.includes('forest')) result.colors.push('G');

            // Check oracle text for mana production - count how many mana symbols
            const addMatch = oracleText.match(/add\s+((?:\{[wubrgc]\}\s*)+)/i);
            if (addMatch) {
                const symbols = addMatch[1].match(/\{([wubrgc])\}/gi) || [];
                result.manaProduced = symbols.length;
                symbols.forEach(sym => {
                    const color = sym.replace(/[{}]/g, '').toUpperCase();
                    if (!result.colors.includes(color)) result.colors.push(color);
                });
            }

            // "Any color" lands/artifacts
            if (oracleText.includes('mana of any color') || oracleText.includes('any one color') ||
                oracleText.includes('one mana of any type') || oracleText.includes('mana of any one color')) {
                result.colors = ['W', 'U', 'B', 'R', 'G'];
            }

            // Check for colorless
            if (result.colors.length === 0 && (oracleText.includes('add {c}') || oracleText.includes('add {1}'))) {
                result.colors.push('C');
            }

            // If still no colors found but it's a land, assume colorless
            if (result.colors.length === 0 && typeLine.includes('land')) {
                result.colors.push('C');
            }

            // Remove duplicates
            result.colors = [...new Set(result.colors)];

            // Calculate net mana
            result.netMana = result.manaProduced - result.activationCost;

            return result;
        }

        // Simple wrapper for backwards compatibility
        function getManaProduction(card) {
            return getManaAbilityInfo(card).colors;
        }

        // Check if a card is a mana source (land or mana-producing artifact)
        function isManaSource(card) {
            const typeLine = (card.type_line || '').toLowerCase();
            const oracleText = (card.oracle_text || '').toLowerCase();

            if (typeLine.includes('land')) return true;
            if (typeLine.includes('artifact') && (oracleText.includes('add {') || oracleText.includes('add one mana'))) return true;
            if (oracleText.includes('{t}: add {') || oracleText.includes('{t}: add one mana')) return true;

            return false;
        }

        // Check if a mana source is "free" (just tap) or requires mana payment
        function isFreeManaSource(card) {
            return getManaAbilityInfo(card).isFree;
        }

        // Get all untapped mana sources on my battlefield
        function getAvailableManaSources() {
            const zones = gameState.zones_data[mySeat];
            if (!zones || !zones.battlefield) return [];

            return zones.battlefield.filter(card => !card.is_tapped && isManaSource(card));
        }

        // Open auto-pay from card modal (finds card by ID)
        function openAutopayFromModal(cardId) {
            closeModal();
            const zones = gameState.zones_data[mySeat];
            const handCard = zones && zones.hand ? zones.hand.find(c => c.id === cardId) : null;
            if (handCard) {
                openAutopayModal(handCard);
            }
        }

        // Open the auto-pay modal
        function openAutopayModal(card) {
            autopayCard = card;
            autopayLandsToTap = [];
            autopayPendingMultiSelections = [];
            autopayManaPool = { W: 0, U: 0, B: 0, R: 0, G: 0, C: 0 };

            // Set card info
            document.getElementById('autopayCardImage').src = card.image_normal || card.image_small;
            document.getElementById('autopayCardName').textContent = card.name;
            document.getElementById('autopayManaCost').innerHTML = renderManaCostSymbols(card.mana_cost);

            // Get available mana sources
            const manaSources = getAvailableManaSources();
            const landsGrid = document.getElementById('autopayLandsGrid');

            if (manaSources.length === 0) {
                landsGrid.innerHTML = '<div style="color:#888;font-size:0.8rem;">Nenhum terreno ou fonte de mana desvirado disponivel.</div>';
                updateAutopayStatus();
                document.getElementById('autopayModal').classList.add('show');
                return;
            }

            // Separate free mana sources from pay-to-activate
            const freeSources = [];
            const payToActivateSources = [];

            manaSources.forEach(source => {
                const info = getManaAbilityInfo(source);
                if (info.isFree) {
                    freeSources.push({ source, info });
                } else {
                    payToActivateSources.push({ source, info });
                }
            });

            // Render available mana sources
            let html = '';

            // Free mana sources first
            if (freeSources.length > 0) {
                html += freeSources.map(({ source, info }) => {
                    const manaHtml = info.colors.map(c => `<span class="mana-symbol ${c}">${c}</span>`).join('');
                    const isMulti = info.colors.length > 1;

                    return `
                        <div class="autopay-land-item ${isMulti ? 'multi-color' : ''}"
                             data-id="${source.id}"
                             data-colors="${info.colors.join(',')}"
                             data-free="true"
                             onclick="toggleAutopayLand('${source.id}')">
                            <img src="${source.image_small}" alt="${source.name}" title="${source.name}">
                            <div class="mana-badge">${manaHtml}</div>
                        </div>
                    `;
                }).join('');
            }

            // Pay-to-activate sources with warning
            if (payToActivateSources.length > 0) {
                html += `<div class="autopay-pay-sources-divider">
                    <span> Fontes que requerem mana para ativar (Signets, etc):</span>
                </div>`;

                html += payToActivateSources.map(({ source, info }) => {
                    const manaHtml = info.colors.map(c => `<span class="mana-symbol ${c}">${c}</span>`).join('');
                    const costInfo = info.activationColor
                        ? `Paga {${info.activationColor}}  gera ${info.manaProduced} mana`
                        : `Paga {${info.activationCost}}  gera ${info.manaProduced} mana`;

                    return `
                        <div class="autopay-land-item pay-to-activate"
                             data-id="${source.id}"
                             data-colors="${info.colors.join(',')}"
                             data-free="false"
                             data-cost="${info.activationCost}"
                             data-produces="${info.manaProduced}"
                             title="${source.name} - ${costInfo}"
                             onclick="toggleAutopayLand('${source.id}')">
                            <img src="${source.image_small}" alt="${source.name}">
                            <div class="mana-badge">${manaHtml}</div>
                            <div class="pay-badge">${info.activationCost}</div>
                        </div>
                    `;
                }).join('');
            }

            landsGrid.innerHTML = html || '<div style="color:#888;font-size:0.8rem;">Nenhuma fonte de mana disponivel.</div>';

            // Try to auto-select lands (only free sources for now)
            autoSelectLands();

            document.getElementById('autopayModal').classList.add('show');
        }

        // Close the auto-pay modal
        function closeAutopayModal() {
            document.getElementById('autopayModal').classList.remove('show');
            document.getElementById('autopayMultiSelect').style.display = 'none';
            autopayCard = null;
            autopayLandsToTap = [];
            autopayPendingMultiSelections = [];
        }

        // Toggle land selection for auto-pay
        function toggleAutopayLand(landId) {
            const landElement = document.querySelector(`.autopay-land-item[data-id="${landId}"]`);
            if (!landElement) return;

            const colors = landElement.dataset.colors.split(',');
            const existingIndex = autopayLandsToTap.findIndex(l => l.id === landId);

            if (existingIndex >= 0) {
                // Deselect
                autopayLandsToTap.splice(existingIndex, 1);
                landElement.classList.remove('selected', 'will-tap');
            } else {
                // Check if it's a multi-color land
                if (colors.length > 1) {
                    showMultiColorSelection(landId, landElement, colors);
                } else {
                    // Single color - just add it
                    autopayLandsToTap.push({ id: landId, color: colors[0] });
                    landElement.classList.add('selected');
                }
            }

            updateAutopayStatus();
        }

        // Show multi-color selection popup for a land
        function showMultiColorSelection(landId, landElement, colors) {
            const zones = gameState.zones_data[mySeat];
            const land = zones.battlefield.find(c => c.id === landId);
            if (!land) return;

            document.getElementById('autopayMultiLandName').textContent = land.name;
            document.getElementById('autopayMultiOptions').innerHTML = colors.map(color => `
                <button class="multi-mana-btn ${color}" onclick="selectMultiManaColor('${landId}', '${color}')">
                    ${color === 'W' ? 'Branco (W)' :
                      color === 'U' ? 'Azul (U)' :
                      color === 'B' ? 'Preto (B)' :
                      color === 'R' ? 'Vermelho (R)' :
                      color === 'G' ? 'Verde (G)' : 'Incolor (C)'}
                </button>
            `).join('');

            document.getElementById('autopayMultiSelect').style.display = 'block';

            // Store reference for selection
            autopayPendingMultiSelections.push({ landId, landElement });
        }

        // Select color for multi-color land
        function selectMultiManaColor(landId, color) {
            const pendingIndex = autopayPendingMultiSelections.findIndex(p => p.landId === landId);
            if (pendingIndex < 0) return;

            const pending = autopayPendingMultiSelections[pendingIndex];
            autopayLandsToTap.push({ id: landId, color: color });
            pending.landElement.classList.add('selected');

            autopayPendingMultiSelections.splice(pendingIndex, 1);

            if (autopayPendingMultiSelections.length === 0) {
                document.getElementById('autopayMultiSelect').style.display = 'none';
            }

            updateAutopayStatus();
        }

        // Auto-select lands to pay mana cost
        function autoSelectLands() {
            if (!autopayCard || !autopayCard.mana_cost) return;

            const cost = parseManaCost(autopayCard.mana_cost);
            const manaSources = getAvailableManaSources();

            // Reset selections
            autopayLandsToTap = [];
            document.querySelectorAll('.autopay-land-item').forEach(el => {
                el.classList.remove('selected', 'will-tap');
            });

            // First, pay colored costs
            const coloredNeeds = { ...cost.colored };

            // Only use FREE mana sources for auto-selection (exclude Signets etc.)
            // Sort lands: single-color first, then multi-color
            const freeSources = manaSources.filter(s => isFreeManaSource(s));
            const sortedSources = [...freeSources].sort((a, b) => {
                const aColors = getManaProduction(a);
                const bColors = getManaProduction(b);
                return aColors.length - bColors.length;
            });

            // Pay colored mana
            for (const color of ['W', 'U', 'B', 'R', 'G']) {
                while (coloredNeeds[color] > 0) {
                    // Find a FREE land that produces this color and isn't selected
                    const source = sortedSources.find(s => {
                        const colors = getManaProduction(s);
                        const alreadySelected = autopayLandsToTap.some(l => l.id === s.id);
                        return colors.includes(color) && !alreadySelected;
                    });

                    if (source) {
                        const colors = getManaProduction(source);
                        if (colors.length > 1) {
                            // Multi-color land - we need user to select
                            const landElement = document.querySelector(`.autopay-land-item[data-id="${source.id}"]`);
                            if (landElement) {
                                landElement.classList.add('will-tap');
                                showMultiColorSelection(source.id, landElement, colors);
                            }
                        } else {
                            autopayLandsToTap.push({ id: source.id, color: color });
                            const landElement = document.querySelector(`.autopay-land-item[data-id="${source.id}"]`);
                            if (landElement) landElement.classList.add('selected');
                        }
                        coloredNeeds[color]--;
                    } else {
                        break; // Can't pay this color with free sources
                    }
                }
            }

            // Pay colorless requirement
            let colorlessNeeded = cost.colorless;
            while (colorlessNeeded > 0) {
                const source = sortedSources.find(s => {
                    const colors = getManaProduction(s);
                    const alreadySelected = autopayLandsToTap.some(l => l.id === s.id);
                    return colors.includes('C') && !alreadySelected;
                });

                if (source) {
                    autopayLandsToTap.push({ id: source.id, color: 'C' });
                    const landElement = document.querySelector(`.autopay-land-item[data-id="${source.id}"]`);
                    if (landElement) landElement.classList.add('selected');
                    colorlessNeeded--;
                } else {
                    break;
                }
            }

            // Pay generic mana with remaining FREE lands
            let genericNeeded = cost.generic + colorlessNeeded; // Add unpaid colorless to generic
            while (genericNeeded > 0) {
                const source = sortedSources.find(s => {
                    const alreadySelected = autopayLandsToTap.some(l => l.id === s.id);
                    return !alreadySelected;
                });

                if (source) {
                    const colors = getManaProduction(source);
                    if (colors.length > 1) {
                        const landElement = document.querySelector(`.autopay-land-item[data-id="${source.id}"]`);
                        if (landElement) {
                            landElement.classList.add('will-tap');
                            showMultiColorSelection(source.id, landElement, colors);
                        }
                    } else {
                        autopayLandsToTap.push({ id: source.id, color: colors[0] || 'C' });
                        const landElement = document.querySelector(`.autopay-land-item[data-id="${source.id}"]`);
                        if (landElement) landElement.classList.add('selected');
                    }
                    genericNeeded--;
                } else {
                    break;
                }
            }

            updateAutopayStatus();
        }

        // Update the status display
        function updateAutopayStatus() {
            if (!autopayCard) return;

            const statusEl = document.getElementById('autopayStatus');
            const confirmBtn = document.getElementById('autopayConfirmBtn');
            const cost = parseManaCost(autopayCard.mana_cost);

            // Calculate what we have selected
            const manaAvailable = { W: 0, U: 0, B: 0, R: 0, G: 0, C: 0, generic: 0 };
            autopayLandsToTap.forEach(land => {
                if (['W', 'U', 'B', 'R', 'G', 'C'].includes(land.color)) {
                    manaAvailable[land.color]++;
                }
            });

            // Check if we can pay the cost
            let canPay = true;
            const missing = [];

            // Check colored mana
            for (const color of ['W', 'U', 'B', 'R', 'G']) {
                if (cost.colored[color] > manaAvailable[color]) {
                    canPay = false;
                    missing.push(`${cost.colored[color] - manaAvailable[color]} ${color}`);
                }
            }

            // Check colorless
            if (cost.colorless > manaAvailable.C) {
                // Can pay colorless with any mana? For now treat as generic
            }

            // Check total for generic
            const totalColoredPaid = Object.values(cost.colored).reduce((a, b) => a + b, 0);
            const totalSelected = autopayLandsToTap.length;
            const genericPaid = totalSelected - totalColoredPaid;

            if (cost.generic > 0 && genericPaid < cost.generic) {
                const neededGeneric = cost.generic - genericPaid;
                if (neededGeneric > 0) {
                    canPay = false;
                    missing.push(`${neededGeneric} generico`);
                }
            }

            // Check if we're waiting for multi-color selections
            if (autopayPendingMultiSelections.length > 0) {
                canPay = false;
                statusEl.innerHTML = `<span style="color:#ffc107;"> Selecione a cor de mana para ${autopayPendingMultiSelections.length} terreno(s) multi-cor</span>`;
                statusEl.className = 'autopay-status';
                confirmBtn.disabled = true;
                return;
            }

            if (canPay && totalSelected >= cost.total) {
                statusEl.innerHTML = ` Mana suficiente! ${totalSelected} fonte(s) serao viradas.`;
                statusEl.className = 'autopay-status success';
                confirmBtn.disabled = false;
            } else if (cost.total === 0) {
                statusEl.innerHTML = ` Esta carta nao tem custo de mana.`;
                statusEl.className = 'autopay-status success';
                confirmBtn.disabled = false;
            } else {
                statusEl.innerHTML = ` Mana insuficiente. Faltando: ${missing.join(', ') || 'mais mana'}. Selecionadas: ${totalSelected}/${cost.total}`;
                statusEl.className = 'autopay-status error';
                confirmBtn.disabled = true;
            }
        }

        // Confirm auto-pay and execute
        function confirmAutopay() {
            if (!autopayCard) return;

            hideContextMenu();

            // Tap all selected lands
            autopayLandsToTap.forEach(land => {
                const zones = gameState.zones_data[mySeat];
                const landCard = zones.battlefield.find(c => c.id === land.id);
                if (landCard && !landCard.is_tapped) {
                    sendAction('tap_card', { object_id: land.id });
                }
            });

            // Move the card to battlefield
            setTimeout(() => {
                moveCard(autopayCard.id, 'battlefield');
                closeAutopayModal();
            }, 100);
        }

        // Event listener for autopay modal
        document.getElementById('autopayModal').addEventListener('click', function(e) {
            if (e.target === this) closeAutopayModal();
        });

        // Initialize local stack references
        updateLocalStackRefs();

        connectWebSocket();
    </script>
</body>
</html>
